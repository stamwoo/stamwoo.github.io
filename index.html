<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Blog of Woo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog of Woo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog of Woo">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Blog of Woo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog of Woo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/面试 - AQS- CAS/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2019/01/02/面试 - AQS- CAS/" class="post-title-link" itemprop="url">谈面试时从写一个单例开始究竟能问多深及终极解决方案</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-02 22:11:29" itemprop="dateCreated datePublished" datetime="2019-01-02T22:11:29+01:00">2019-01-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转 <a href="http://www.cnblogs.com/xiexj/p/6845029.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiexj/p/6845029.html</a></p>
<p>看了左潇龙的《<a href="http://www.cnblogs.com/zuoxiaolong/p/life51.html" target="_blank" rel="noopener">回答阿里社招面试如何准备，顺便谈谈对于 Java 程序猿学习当中各个阶段的建议</a>》这篇文章，在想一个问题，从一个最简单的问题入手究竟能把问题问多深？下面就模拟一场面试问答，要是我是面试官，大概就只能问到下面的深度了。</p>
<p>旁白：一般的面试都是从最简单基本的问题开始。</p>
<p>面试官：请在黑板上写出一个线程安全的单例模式的例子。</p>
<p>面试者：</p>
<p>　　其实线程安全的实现有很多种，根据业务场景可以 new 一个实例作为私有静态成员变量，这样程序一启动，实例就生成，私有化构造函数，利用公用的静态函数 getInstance 返回实例。这种预加载的是能保证线程安全的但是如果不是确定会被使用，会造成内存的浪费，所以可以将实例放到私有静态类中作为成员变量。下面只写一种利用锁机制来保证的懒加载方法。</p>
<pre>public class Singleton { 
    private volatile static Singleton singleton; 
    private Singleton (){} 
    public static Singleton getSingleton() { 
    if (singleton == null) { 
        synchronized (Singleton.class) { 
        if (singleton == null) { 
            singleton = new Singleton(); 
        } 
        } 
    } 
    return singleton; 
    } 
}</pre>

<p>或者</p>
<pre>public class Singleton{    
    private static Singletoninstance = new Singleton();
    private Singleton(){}

    public static Singleton getInstance() {
        return instance;
    }
}</pre>

<p>旁白：从这个例子上我能想到的知识点主要有三个</p>
<p>　　   ☆　volatile 关键字，可深入到 Java VM 内存相关</p>
<p>　　   ☆　synchronized 关键字，可深入到 Java 锁机制，高并发相关</p>
<p>　　   ☆　new 关键字，可深入到 Java VM 类加载机制相关</p>
<p>但是面试官一开始可能要先考察一下面试者是否真的理解自己写的代码</p>
<p>面试官：你写的这个程序是怎么保证线程安全的？</p>
<p>面试者：将类的构造方法私有起来，外部调用进行初始化的时候只能通过调用 getSingleton 这个静态方法来获得实例，静态方法是整个 Java 虚拟机中只有一个实例。在创建的时候首先进行非空判断，这时候如果实例不存在，对整个类进行加锁同步，为了避免过程中非空状态的改变，同步块内再进行一次判断，如果不存在实例则创建实例返回。使用 volatile 关键字，下次访问这个方法就能直接看到实例的最新非空状态，直接返回实例。</p>
<p>面试官：volatile 起到了什么作用？</p>
<p>面试者：volatile 这个英文单词意思是易变的，用在多线程中来同步变量。Java 的对象都是在内存堆中分配空间。但是 Java 有主内存和线程自己独有的内存拷贝。对于没有 volatile 修饰的局部变量，线程在运行过程中访问的是工作内存中的变量值，其修改对于主内存不是立即可见。而 volatile 修饰的值在线程独有的工作内存中无副本，线程直接和主内存交互，修改对主内存立即可见。</p>
<p>面试官：synchronized 起到了什么作用？</p>
<p>面试者：锁定对象，限制当前对象只能被一个线程访问。</p>
<p>面试官：synchronized 里你传 Singleton.class 这个参数，起到什么作用，换成别的行不行？</p>
<p>面试者：对当前类加锁，使得这个代码块一次只能被一个线程访问。这里 Singleton.class 可以换成一个常量字符串或者自己定义一个内部静态 Object。</p>
<p>面试官：那传 Singleton.class，常量字符串，自己定义一个内部静态 Object 有区别吗？</p>
<p>面试者：因为这是一个静态方法，相当于一个概念上的类锁，所以在这里起到的效果是一样的。但是如果是原型模式，或者直接每个类都是 new 出来的，实例不同的话，在一个非静态方法里加这三种锁，这时是一个对象锁，因为 Singleton.class 或者是静态的一个 Object 或者是 JVM 只存一份的字符串常量，这些对象线程间是共享的，会对所有的实例的同步块都加同一把锁，每个实例访问到此对象的同步代码块都会被阻塞。但是如果这时 synchronized 的参数是 this，或者是内部 new 出来的一个内部非静态 Object，则各个实例拥有不同的锁，访问同一个代码相同同步块也是互不干扰。只有实例内部使用了同一个对象锁才会同步等待。</p>
<p>面试官：那你知道 synchronized 关键字实现同步的原理吗？</p>
<p>面试者：synchronized 在 Java 虚拟机中使用监视器锁来实现。每个对象都有一个监视器锁，当监视器锁被占用时就会处于锁定状态。</p>
<p>　　线程执行一条叫 monitorenter 的指令来获取监视器锁的所有权。如果此监视器锁的进入数为 0，则线程进入并将进入数设置为 1，成为线程所有者。如果线程已经拥有该锁，因为是可重入锁，可以重新进入，则进入数加 1. 如果线程的监视器锁被其他线程占用，则阻塞直到此监视器锁的进入数为 0 时才能进入该锁。</p>
<p>　　线程执行一条叫 monitorexit 的指令来释放所有权。执行 monitorexit 的必须是线程的所有者。每次执行此指令，线程进入数减 1，直到进入数为 0。监视器锁被释放。</p>
<p>面试官：你刚才提到的可重入锁是什么概念，有不可重入锁吗？</p>
<p>面试者：我说的可重入锁是广义的可重入锁，当然 jdk1.5 引入了 concurrent 包，里面有 Lock 接口，它有一个实现叫 ReentrantLock。广义的可重入锁也叫递归锁，是指同一线程外层函数获得锁之后，内层还可以再次获得此锁。可重入锁的设计是为了避免死锁。sun 的 corba 里的 mutex 互斥锁是一种不可重入锁的实现。自旋锁也是一种不可重入锁，本质上是一种忙等锁，CPU 一直循环执行 “测试并设置” 直到可用并取得该锁，在递归的调用该锁时必然会引起死锁。另外，如果锁占用时间较长，自旋锁会过多的占用 CPU 资源，这时使用基于睡眠原理来实现的锁更加合适。</p>
<p>面试官：你刚才提到了 concurrent 包，它里面有哪些锁的实现？</p>
<p>面试者：常用的有 ReentrantLock, 它是一种独占锁。ReadWriteLock 接口也是一个锁接口，和 Lock 接口是一种关联关系，它返回一个只读的 Lock 和只写的 Lock。读写分离，在没有写锁的情况下，读锁是无阻塞的，提高了执行效率，它是一种共享锁。ReadWriteLock 的实现类为 ReentrantReadWriteLock。ReentrantLock 和 ReentrantReadWriteLock 实现都依赖于 AbstractQueuedSynchronizer 这种抽象队列同步器。</p>
<p>面试官：锁还有其他维度的分类吗？</p>
<p>面试者：还可以分为公平锁和非公平锁。非公平锁是如果一个线程尝试获取锁时可以获取锁，就直接成功获取。公平锁则在锁被释放后将锁分配给等待队列队首的线程。</p>
<p>面试官：AQS 是什么？</p>
<p>面试者：AQS 是一个简单的框架，这个框架为同步状态的原子性管理，线程的阻塞和非阻塞以及排队提供了一种通用机制。表现为一个同步器，主要支持获取锁和释放锁。获取锁的时候如果是独占锁就有可能阻塞，如果是共享锁就有可能失败。如果是阻塞，线程就要进入阻塞队列，当状态变成可获得锁就修改状态，已进入阻塞队列的要从阻塞队列中移除。释放锁时修改状态位及唤醒其他被阻塞的线程。</p>
<p>AQS 本质是采用 CHL 模型完成了一个先进先出的队列。对于入队，采用 CAS 操作，每次比较尾节点是否一致，然后插入到尾节点中。对于出队列，因为每个节点缓存了一个状态位，不满足条件时自旋等待，直到满足条件时将头节点设置为下一个节点。</p>
<p>面试官：那知道这个队列的数据结构吗？</p>
<p>面试者：这个队列是用一个双向链表实现的。</p>
<p>面试官：你刚才提到 AQS 是一种通用机制，那它还有哪些应用?</p>
<p>面试者：AQS 除了刚才提到的可重入锁 ReentrantLock 和 ReentrantReadWriteLock 之外，还用于不可重入锁 Mutex 的实现。java 并发包中的同步器如：Semphore,CountDownLatch,FutureTask,CyclicBarrier 都是采用这个机制实现的。</p>
<p>旁白：既然问到了并发工具包中的东西，每个都可以引出一堆，但是基本原理已经问出来了，其他的问下去没什么意思。转向下一个问题。</p>
<p>面试官：你黑板上写的实例是通过 new 对象创建出来的，还可不可以采用别的方法来创建对象呢？</p>
<p>面试者：还可以使用 class 类的 newInstance 方法，Constructor 构造器类的 newInstance 方法，克隆方法和反序列法方法。</p>
<p>面试官：两种 newInstance 方法有没有区别？</p>
<p>面试者：</p>
<p>　　☆　Class 类位于 java 的 lang 包中，而构造器类是 java 反射机制的一部分。</p>
<p>　　☆　Class 类的 newInstance 只能触发无参数的构造方法创建对象，而构造器类的 newInstance 能触发有参数或者任意参数的构造方法来创建对象。</p>
<p>　　☆　Class 类的 newInstance 需要其构造方法是共有的或者对调用方法可见的，而构造器类的 newInstance 可以在特定环境下调用私有构造方法来创建对象。</p>
<p>　　☆　Class 类的 newInstance 抛出类构造函数的异常，而构造器类的 newInstance 包装了一个 InvocationTargetException 异常。</p>
<p>　　Class 类本质上调用了反射包构造器类中无参数的 newInstance 方法，捕获了 InvocationTargetException，将构造器本身的异常抛出。</p>
<p>面试官：类加载的时候，自己定义了一个类和 java 自己的类类名和命名空间都一样，JVM 加载的是哪一个呢？</p>
<p>面试者：调用的是 java 自身的，根据双亲委派模型，最委派 Bootstrap 的 ClassLoader 来加载，找不到才去使用 Extension 的 ClassLoader，还找不到才去用 Application 的 ClassLoader，这种机制利于保证 JVM 的安全。</p>
<p>面试官：你刚才提到的 java 的反射机制是什么概念？</p>
<p>面试者：java 的反射机制是在运行状态中，对于任何一个类，都能够知道它所有的属性和方法；对于任何一个对象，都能够调用它的任何一个方法和属性。这种动态的获取信息和动态调用对象的方法的功能就是 java 的反射机制。它是 jdk 动态代理的实现方法。</p>
<p>面试官：java 还有没有其他的动态代理实现？</p>
<p>面试者：还有 cglib 动态代理。</p>
<p>面试官：这两种动态代理哪个比较好呢？</p>
<p>面试者：AOP 源码中同时使用了这两种动态代理，因为他们各有优劣。jdk 动态代理是利用 java 内部的反射机制来实现，在生成类的过程中比较高效，cglib 动态代理则是借助 asm 来实现，可以利用 asm 将生成的类进行缓存，所以在类生成之后的相关执行过程中比较高效。但是 jdk 的动态代理前提是目标类必须基于统一的接口，所以有一定的局限性。</p>
<p>旁白：面试者都已经提到 AOP 了，那么接下来横向，纵向，怎样都能问出一大堆问题，就不赘述。基于上面问题，读者也可以自己画出一棵知识树，然后就能找到能对答如流的终极方案：就是基本都没超过《深入理解 java 虚拟器》《java 并发编程实践》这两本书，大学学过的《数据结构与算法》《编译原理》掌握的好也可以在面试中加分哦。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/TCP为什么是三次握手/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/TCP为什么是三次握手/" class="post-title-link" itemprop="url">TCP为什么是三次握手</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP为什么是三次握手"><a href="#TCP为什么是三次握手" class="headerlink" title="TCP为什么是三次握手"></a>TCP为什么是三次握手</h1><p>TCP为什么建立连接是三次握手? 对于C和S来说,双方均需要确认对方和自己的发送信息能力和接受信息能力是OK的.<br>拿一次完整的三次握手来举例:   </p>
<ul>
<li>第一次握手:C和S什么都不能确认.</li>
<li>第二次握手:C确认了自己的发送能力和接受能力,S确认了自己的接受能力.</li>
<li>第三次握手:S确认了自己的发送能力.</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/mysql explain 详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/mysql explain 详解/" class="post-title-link" itemprop="url">mysql explain 详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql-explain-详解"><a href="#mysql-explain-详解" class="headerlink" title="mysql explain 详解"></a>mysql explain 详解</h1><h2 id="语法及描述"><a href="#语法及描述" class="headerlink" title="语法及描述"></a>语法及描述</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>在 select 语句前加上 explain 关键字就可以</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>获取查询操作的执行顺序<br>使用到的索引<br>成功返回结果需要执行的行数</p>
<h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>标识符, 表示执行顺序. id 一样则自上而下, 否则大的先执行.</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询类型</p>
<ol>
<li>simple: 不包含 union 操作或者不包含子查询的简单 select 查询</li>
<li>primary: 需要 union 操作或者含有子查询的 select, 位于最外层的 select.type 即为 primary, 且只有一个.</li>
<li>union:union 链接的两个 select 查询, 第一个是 primiary, 第二个之后的都是 union.</li>
<li>Dependent union: 出现在 union 或 union all 语句, 但是这个查询要收到外部查询的影响.</li>
<li>union result: 包含 union 的结果集, 在 union 和 union all 语句中, 因为它不需要参与查询,, 所以 id 字段为 null</li>
<li>subquery: 除了 from 子句中包含的子查询外, 其他地方出现的子查询都可能是 subquery</li>
<li>Dependent subquery: 与 dependent union 类似, 表示这个 subquery 的查询要受到外部表查询的影响</li>
<li>derived:from 子句中出现的子查询, 也叫做派生表, 其他数据库中可能叫做内联师徒或嵌套 select</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//外层是primary,内层是subquery</span><br><span class="line">explain select * from student s where s. classid = (select id from classes where classno=&apos;2017001&apos;);</span><br><span class="line"></span><br><span class="line">//结果有三行,第一行是primary,第二行是union,第三行是union result</span><br><span class="line">explain select * from student where id = 1 union select * from student where id = 2;</span><br><span class="line"></span><br><span class="line">//结果有四行,分别是primary,dependent subquery,dependent union,union result</span><br><span class="line">explain select * from student s where s.classid in (select id from classes where classno=&apos;2017001&apos; union select id from classes where classno=&apos;2017002&apos;);</span><br><span class="line"></span><br><span class="line">//跟mysql版本有关</span><br><span class="line">explain select * from (select * from student) s;</span><br><span class="line">table</span><br><span class="line">显示查询语句所查询的表名,如果查询使用了别名,那么这里使用的是别名.如果不涉及对数据表的操作,显示为null;有一种特殊情况,如果显示为,,则都是临时表.M,N代表的id,表示结果来自于这个查询产生</span><br></pre></td></tr></table></figure>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>表是分区表才行</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>查询结果类型</p>
<ol>
<li>const: 返回结果只有一个匹配行</li>
<li>range: 索引范围扫描，常见于使用 &gt;,&lt;,is null,between ,in ,like 等运算符的查询中</li>
<li>index: 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</li>
<li>index_merge: 使用了一张表的多个索引, 实际上由于要读取所个索引，性能可能大部分时间都不如 range<br>全表扫描数据文件</li>
<li><p>possible_keys &amp; key<br>possible_keys: 查询可能使用到的索引都会在这里列出来。</p>
</li>
<li><p>key: 查询真正使用到的索引，select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个。</p>
</li>
<li><p>key_len<br>用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。</p>
</li>
</ol>
<p>留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对上面 explain 中的每个字段的详细讲解。我们不难看出，对查询性能影响最大的几个列是：</p>
<ul>
<li>select_type：查询类型</li>
<li>type: 连接使用了何种类型</li>
<li>rows: 查询数据需要用到的行</li>
<li>key: 查询真正使用到的索引</li>
<li>extra: 额外的信息<br>尽量让自己的 SQL 用上索引，避免让 extra 里面出现 file sort(文件排序),using temporary(使用临时表)。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/spring boot 扫描不到自定义 Controller/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/spring boot 扫描不到自定义 Controller/" class="post-title-link" itemprop="url">spring cloud 扫不到自定义controller</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 springboot 官网照着给的介绍写了个 springboot 程序</p>
<p>pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>java 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.*;</span><br><span class="line">import org.springframework.boot.autoconfigure.*;</span><br><span class="line">import org.springframework.stereotype.*;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">public class Application&#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    String home() &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SpringApplication.run(SampleController.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后自己写了个 Controller</p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409005618644-1487234010.png" alt=""></p>
<p>但是无论如何也无法扫描到自己定义的 Controller（如果用的是 idea，能明显看出来，如果扫描到会有<img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409005713894-1428437850.png" alt="">的图标）。访问结果结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409005517644-1213300216.png" alt=""></p>
<p>报错的原因是找不到对应的映射路径，即 Controller 没有被扫描到 ，。</p>
<p>郁闷至极，到晚上搜的结果说的是 LoginController 方的位置不对，应该让启动类和 Controller 的包在同一级目录下，然而对我却没有效果。</p>
<p>官方建议 application.java 放的位置：</p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409004634847-1050076443.png" alt=""></p>
<p>最后尝试了下修改下 Application 上的注解，<strong>我本来复制官方的代码用的是 @Controller 和 <em>@EnableAutoConfiguration，试着换成了 @</em>**</strong>SpringBootApplication<strong> </strong>注解**，出乎意外的可以扫描到 Controller </p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409010006191-38718118.png" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409010021238-427644219.png" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409010114410-919234476.png" alt=""></p>
<p>又查了下官方的文档终于找到原因了，原因是：</p>
<p>如果使用 @Controller 和 <em>@EnableAutoConfiguration 注解还应该再加上一个注解：</em>@ComponentScan  就可以了。@Controller 和 @EnableAutoConfiguration 没有扫描注解的功能，而 @ComponentScan 是</p>
<p> springboot 专门用来扫描 @Component, @Service, @Repository, @Controller 等注解的注解</p>
<p>总结：</p>
<p>使用 springboot 启动类配置扫描的两种注解配置方式：</p>
<p>1、@Controller</p>
<p> @EnableAutoConfiguration</p>
<p> @ComponentScan</p>
<p>2、@SpringBootApplication</p>
<p>@SpringBootApplication 注解等价于 @Configuration, @EnableAutoConfiguration and @ComponentScan</p>
<pre>另外application.java（启动类）也应该按照官方的建议放在root目录下，这样才能扫描到Service和dao，不然还会引起，扫描不到注解的问题。
**--- 更新日期：2018-10-14 ---**
最近用了最新的springboot 2.0.5.RELEASE 版本 多了一种新的扫描注解，新版的springboot application可以放在任意位置，只要加上</pre>

<p><pre>@ComponentScan(basePackages = {“com.oskyhang”, “com.frames”})</pre></p>
<p>注解就可以，注解指定扫描的包，就可以扫描到，更灵活方便。</p>
<p> PS：如有疑问或错误，欢迎指教。3Q</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/为什么你需要一个 vps/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/为什么你需要一个 vps/" class="post-title-link" itemprop="url">为什么你需要一个VPS</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="VPS-是什么"><a href="#VPS-是什么" class="headerlink" title="VPS 是什么"></a>VPS 是什么</h1><p>VPS 是 Virtual private server 的简称，中文是 “虚拟专用服务器”，是指通过虚拟化技术在独立服务器中运行的专用服务器。每个使用 VPS 技术的虚拟独立服务器拥有各自独立的公网 IP 地址、操作系统、硬盘空间、内存空间、CPU 资源等，还可以进行安装程序、重启服务器等操作，与运行一台独立服务器基本相同。</p>
<p>很多人有点分不清 VPS 与虚拟主机的区别，网上也有很多人说过这个。博主这里就不长篇大论了，简单说，VPS 就相当于一台真正的电脑，只不过这台电脑是放在别人家的。你可以通过 ssh 工具对它做任何事，只要你开心，你砸了它也行。<br>而虚拟主机说到底是别人家的电脑借给你用，你可以使用上面的计算资源，虚拟主机的服务商已经给你提供各种安装好的工具以及计算资源。但你对它的权限是比不上 VPS 大的。</p>
<h1 id="VPS-可以用来做什么"><a href="#VPS-可以用来做什么" class="headerlink" title="VPS 可以用来做什么"></a>VPS 可以用来做什么</h1><h2 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h2><p>使用 Python、C++、C# 等语言开发、基于 Apache 许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks 使用 Socks5 代理方式。<br>Shadowsocks 分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。<br>其实关于在 vps 搭建 SS 的教程已经很多了，但是博主之前搭梯子的时候发现很多教程存在一些问题，或者是太繁琐，或者是很多重要地方过了一段时间已经发生了变化，对小白用户不太友好。</p>
<p>因此博主决定写一篇新的教程分享出来。</p>
<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>搭建一个属于自己的博客，搭配上 github education 提供的工具包，还可以获得一个免费域名及 SSL 认证。博主这个博客既是使用我说的这种方案搭建的。过程十分简单，按照博主的上一篇教程：在自己的 VPS 上从零开始搭建 Hexo 博客, 半天时间即可搭建完成并上线。</p>
<h2 id="Seafile"><a href="#Seafile" class="headerlink" title="Seafile"></a>Seafile</h2><p>一套中国国产的开源、专业、可靠的云存储项目管理软件，[解决文件集中存储、共享和跨平台访问等问题。正式发布于 2012 年 10 月。除了一般网盘所提供的云存储以及共享功能外，Seafile 还提供消息通信、群组讨论等辅助功能，帮助员工更好的围绕文件展开协同工作，已有 10 多万用户使用。</p>
<p>作为一套比较成熟的管理软件，Seafile 的安装也十分简单。Install Seafile Client on Linux</p>
<p>此外，你还可以在 VPS 部署更多你自己写的脚本，比如爬虫类工具，抢票程序等等。一句话，只要是你的程序有 7*24h 的服务时间需求，你都可以把它放在你的 VPS 上跑。</p>
<h1 id="VPS-哪家强"><a href="#VPS-哪家强" class="headerlink" title="VPS 哪家强"></a>VPS 哪家强</h1><p>看了上面的内容，如果你想选择一家 VPS 提供商，那么你大概有哪些选择呢？博主也给出了当下比较流行，有口碑的 VPS 服务商供大家参考。</p>
<h2 id="DigitalOcean"><a href="#DigitalOcean" class="headerlink" title="DigitalOcean"></a>DigitalOcean</h2><p>一家位于美国的云主机服务商，总部位于纽约，成立于 2012 年。由于价格低廉，高性能配置、灵活布置的优势，近些年来发展迅猛，成为中国站长圈们喜爱的品牌。该公司拥有多个数据中心：日本东京、美国 洛杉矶、纽约、新泽西、新加坡、英国伦敦、德国富兰克林.</p>
<p>DigitailOcean，博主习惯称为 DO。也是博主选择的第一家 VPS 服务商，对于博主这种学生党而言，DO 是最具有性价比的一家服务商，由邀请链接注册自动赠送 $10 的优惠，再通过 paypal 充值 $5 即可使用。如果是学生用户的话使用 github education 提供的学生开发包可以再获得 $50 的优惠码。也就是说 $5 就可以使用 DO 的 1G 25gSSD 的 VPS 长达 13 个月，这性价比也是没谁了吧。</p>
<p>我的邀请链接是：$10 邀请链接, 另外为了选择合适的机房，再贴一个测速链接：SFO2 Speedtest | DigitalOcean</p>
<h2 id="Linode"><a href="#Linode" class="headerlink" title="Linode"></a>Linode</h2><p>一个建立于美国新泽西州加洛伟的虚拟专用服务器（VPS）提供商。它的名字是由英文中 Linux 中的 Li 和 node（即 “节点” 一词）构成的混成词。如同它的名字一样，Linode 只提供运行 Linux 的服务器，而不提供运行 Windows Server 的服务器。它的服务一向以稳定著称。</p>
<p>知乎在发展初期使用的就是 Linode 的服务，现在口碑比较好的比较稳定的就是日本机房了，不过是要抢购，基本每每放出来都被抢完了。</p>
<h2 id="搬瓦工"><a href="#搬瓦工" class="headerlink" title="搬瓦工"></a>搬瓦工</h2><p>隶属于加拿大 IT7 旗下的 VPS 服务品牌，主推 OPENVZ 架构方案，尤其是其中的 4 款便宜年付 VPS 深受广大用户的喜欢，支持支付宝付款，旗下有四个机房，均支持一键切换机房位置以及一键安装各类软件等功能。</p>
<p>这家前些年应该是最火的 vps 服务商了，记得曾经有 $5 的年 vps，小内存搭个 ss 还是很够用的。后来因为 ip 资源枯竭，搬瓦工拿不到什么 ip 就停了自家的超低资费服务。不过现在还是有 $19.99 的资费可以选。</p>
<h2 id="Vultr"><a href="#Vultr" class="headerlink" title="Vultr"></a>Vultr</h2><p>一家 2014 年刚成立的 VPS 服务商，基于 KVM，采用 SSD 硬盘，拥有大量自建机房。有日本、美国洛杉矶、Dallas、Chicago、New York、Seattle、Atlanta、英国、德国等，价格便宜，配置又高。支持 Paypal、信用卡或比特币付款。</p>
<p>这家比较好的依然是日本主机，国内 ping 值在 100 以内，也较少抽风。另外他家的最低配置也比别家高，价格嘛，自然就水涨船高了。博主作为一个学生党目前觉得还没太必要用他家，以后说不定想试一试。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/为什么匿名内部类访问局部变量必须是 final/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/为什么匿名内部类访问局部变量必须是 final/" class="post-title-link" itemprop="url">为什么匿名内部类访问局部变量必须是final?</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一个谜团"><a href="#一个谜团" class="headerlink" title="一个谜团"></a>一个谜团</h2><p>如果你用过类似 guava 这种 “伪函数式编程” 风格的 library 的话，那下面这种风格的代码对你来说应该不陌生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void tryUsingGuava() &#123;</span><br><span class="line">    final int expectedLength = 4;</span><br><span class="line">    Iterables.filter(Lists.newArrayList(&quot;123&quot;, &quot;1234&quot;), new Predicate&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean apply(String str) &#123;</span><br><span class="line">            return str.length() == expectedLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码对一个字符串的 list 进行过滤，从中找出长度为 4 的字符串。看起来很是平常，没什么特别的。</p>
<p>但是，声明 expectedLength 时用的那个 final 看起来有点扎眼，把它去掉试试：</p>
<blockquote>
<p>error: local variable expectedLength is accessed from within inner class; needs to be declared final</p>
</blockquote>
<p>结果 Java 编译器给出了如上的错误，看起来匿名内部类只能够访问 final 的局部变量。但是，<strong>为什么呢？其他的语言也有类似的规定吗？</strong></p>
<p>在开始用其他语言做实验之前我们先把问题简化一下，不要再带着 guava 了，我们去除掉噪音，把问题归结为：</p>
<p><strong>为什么 Java 中的匿名内部类只可以访问 final 的局部变量呢？其他语言中的匿名函数也有类似的限制吗？</strong></p>
<h2 id="Scala-中有类似的规定吗？"><a href="#Scala-中有类似的规定吗？" class="headerlink" title="Scala 中有类似的规定吗？"></a>Scala 中有类似的规定吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def tryAccessingLocalVariable &#123;</span><br><span class="line">  var number = 123</span><br><span class="line">  println(number)</span><br><span class="line"></span><br><span class="line">  var lambda = () =&gt; &#123;</span><br><span class="line">    number = 456</span><br><span class="line">    println(number)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lambda.apply()</span><br><span class="line">  println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> |</p>
<p>上面的 Scala 代码是合法的，number 变量是声明为 var 的，不是 val（类似于 Java 中的 final）。而且在匿名函数中可以修改 number 的值。</p>
<p>看来 <strong>Scala 中没有类似的规定</strong>。</p>
<h2 id="C-中有类似的规定吗？"><a href="#C-中有类似的规定吗？" class="headerlink" title="C# 中有类似的规定吗？"></a>C# 中有类似的规定吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void tryUsingLambda ()</span><br><span class="line">&#123;</span><br><span class="line">  int number = 123;</span><br><span class="line">  Console.WriteLine (number);</span><br><span class="line"></span><br><span class="line">  Action action = () =&gt; &#123;</span><br><span class="line">      number = 456;</span><br><span class="line">      Console.WriteLine (number);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  action ();</span><br><span class="line">  Console.WriteLine (number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段 C# 代码也是合法的，number 这个局部变量在 lambda 表达式内外都可以访问和赋值。</p>
<p>看来 <strong>C# 中也没有类似的规定</strong>。</p>
<h2 id="分析谜团"><a href="#分析谜团" class="headerlink" title="分析谜团"></a>分析谜团</h2><p>三门语言中只有 Java 有这种限制，那我们分析一下吧。先来看一下 Java 中的匿名内部类是如何实现的：</p>
<p>先定义一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建这个接口的匿名子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TryUsingAnonymousClass &#123;</span><br><span class="line">    public void useMyInterface() &#123;</span><br><span class="line">        final Integer number = 123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        MyInterface myInterface = new MyInterface() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doSomething() &#123;</span><br><span class="line">                System.out.println(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myInterface.doSomething();</span><br><span class="line"></span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个匿名子类会被编译成一个单独的类，反编译的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class TryUsingAnonymousClass$1</span><br><span class="line">        implements MyInterface &#123;</span><br><span class="line">    private final TryUsingAnonymousClass this$0;</span><br><span class="line">    private final Integer paramInteger;</span><br><span class="line"></span><br><span class="line">    TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) &#123;</span><br><span class="line">        this.this$0 = this$0;</span><br><span class="line">        this.paramInteger = paramInteger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(this.paramInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到名为 number 的局部变量是作为构造方法的参数传入匿名内部类的（以上代码经过了手动修改，真实的反编译结果中有一些不可读的命名）。</p>
<p>如果 Java 允许匿名内部类访问非 final 的局部变量的话，那我们就可以在 TryUsingAnonymousClass$1 中修改 paramInteger，但是这不会对 number 的值有影响，因为它们是不同的 reference。</p>
<p>这就会造成数据不同步的问题。</p>
<p>所以，<strong>谜团解开了：Java 为了避免数据不同步的问题，做出了匿名内部类只可以访问 final 的局部变量的限制。</strong></p>
<p>但是，新的谜团又出现了：</p>
<h2 id="Scala-和-C-为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？"><a href="#Scala-和-C-为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？" class="headerlink" title="Scala 和 C# 为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？"></a>Scala 和 C# 为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？</h2><p>上面出现过的那段 Scala 代码中的 lambda 表达式会编译成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class TryUsingAnonymousClassInScala$$anonfun$1 extends AbstractFunction0.mcV.sp</span><br><span class="line">        implements Serializable &#123;</span><br><span class="line">    public static final long serialVersionUID = 0L;</span><br><span class="line">    private final IntRef number$2;</span><br><span class="line"></span><br><span class="line">    public final void apply() &#123;</span><br><span class="line">        apply$mcV$sp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void apply$mcV$sp() &#123;</span><br><span class="line">        this.number$2.elem = 456;</span><br><span class="line">        Predef..MODULE$.println(BoxesRunTime.boxToInteger(this.number$2.elem));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TryUsingAnonymousClassInScala$$anonfun$1(TryUsingAnonymousClassInScala $outer, IntRef number$2) &#123;</span><br><span class="line">        this.number$2 = number$2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 number 也是通过构造方法的参数传入的，但是与 Java 的不同是这里的 number 不是直接传入的，是被 IntRef 包装了一层然后才传入的。对 number 的值修改也是通过包装类进行的：this.number$2.elem = 456;</p>
<p>这样就保证了 lambda 表达式内外访问到的是同一个对象。</p>
<p>再来看看 C# 的处理方式，反编译一下，发现 C# 编译器生成了如下的一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private sealed class &lt;tryUsingLambda&gt;c__AnonStorey0</span><br><span class="line">&#123;</span><br><span class="line">  internal int number;</span><br><span class="line"></span><br><span class="line">  internal void &lt;&gt;m__0 ()</span><br><span class="line">  &#123;</span><br><span class="line">      this.number = 456;</span><br><span class="line">      Console.WriteLine (this.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 number 包装在这个类内，这样就保证了 lambda 表达式内外使用的都是同一个 number，即便重新赋值也可以保证内外部的数据是同步的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Scala 和 C# 的编译器通过把局部变量包装在另一个对象中，来实现 lambda 表达式内外的数据同步。</p>
<p>而 Java 的编译器由于未知的原因（怀疑是为了图省事儿？）没有做包装局部变量这件事儿，于是就只好强制用户把局部变量声明为 final 才能在匿名内部类中使用来避免数据不同步的问题。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/既然Java反射可以访问和修改私有成员变量，那封装成private的意义/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/既然Java反射可以访问和修改私有成员变量，那封装成private的意义/" class="post-title-link" itemprop="url">既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？"><a href="#既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？" class="headerlink" title="既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？"></a>既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？</h1><p>简单来说，private并不是解决“安全”问题的。<br>安全是指不让代码被非法看到/访问。但是只要人能拿到代码，总会有办法去查看和改变代码。<br>其他答案提到反射可以用SecurityManager来防止private被访问。但是从更高一层的角度，即便使用了SecurityManager，还是可以通过各种方式拿到java的bytecode，并做任意修改。比如有asm这样的lib，也有instrument api这种东西可以帮你。<br>所以记得，如果你真有一段代码不允许被别人看/用，就不要把这段代码放到其他人可以碰到的地方，而是做一个server，通过接口允许有限制的访问。其他人想破解，只能破解你的服务器网关和跳板机器。<br>关于真正的安全性，可以参考激活服务器的工作原理.<br>private想表达的不是“安全性”的意思，而是OOP的封装概念，是一种编译器可以帮助你的设计上的hint。这就像是一家没人的店挂了个牌子“闲人免进”，但你真要进去还是有各种办法可以办到。所以private，以及所有其他的access modifier都有一层隐含的含义：如果你按照遵守这套规则，开发者可以保证不问题（不考虑bug的情况下）；否则，后果自负。比如，你在用spring的IoC的时候，你知道你要“注入”，不管它是不是private的，你知道“注入”是你自己控制的，是你设计好的效果。那么通过spring的IoC利用反射帮你注入一些private property是再正常不过的用法。再比如，单元测试，你就想测一个private方法。但是因为private的缘故就是测不了。于是你可以用反射绕开这个限制，开心的做测试。虽说某些人坚持“不应该测试private方法，而应该通过测试其他方法间接测试private方法，但并没有形成广泛的共识。这里不对这个问题展开。虽然能绕开，但绕开的代码很繁琐。久而久之就会厌倦。毕竟，代码应该为你工作，而不是你为代码工作。<br>因此，我的经验是通常会用protected或者default来代替private。我曾设想runtime应该给一种运行模式，通过设定一个启动参数使其不管private这类的限制，这样做UT，做profiling等工作都会轻松许多。等到最后发布时，再用普通模式。但可惜现实当中并没有这种设定。评论区提到了Android里的VisibleForTesting，可以实现我期望的功能。大赞！感谢 @尤华杰<br>我之所以敢用protected/default来代替private是因为现实当中非private不可的情景非常少见。实际上，很多时候private带来的麻烦比起带来的好处要多，这是因为很多时候对OOP的误用造成的。OOP的误用造成了无谓的private，然后逼着你必须得绕开private。其实private就是个约定而已。<br>看看其他语言，比如python，它的“private“是一种很松散的约定，所有private的成员都用下划线开头，告诉调用者“不要随便调用我哦”，但是如果真调用了也就调用了。C++，通过指针就能绕开private。<br>有人说，private会避免新手误用。但问题是，大家从出道开始，自己或者周围的同事朋友有谁曾经出过这个问题？IDE知道一个成员当前不能访问，就根本就不会提示。如果一个人已经开始通过源代码/反编译研究“我能不能调用这个私有方法了“，他还算是一个菜鸟吗？他会不知道这里的潜在风险吗？如果真的误用了，code review能过吗？测试能过吗？如果一个公司因为误用private成员，造成了重大的损失，那这个公司就活该倒闭算了，不要在世上丢人。<br>OOP是一种编程思想，是众多编程思想中的一种。是开发者决定了一个问题应该用OOP合适，并且用了Java这样的语言来简化自己开发OOP代码时的工作。如果抱着这种态度，就不会误用，因为private在开发者的心中。其他人也不太可能误用，如果他上过几天java培训。不要因为语言是OOP的就去套，把不适合的OOP的代码强用OOP的各种套路实现，然后给自己后续的维护扩展埋坑。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/线上服务 CPU100% 问题快速定位实战/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/线上服务 CPU100% 问题快速定位实战/" class="post-title-link" itemprop="url">线上服务CPU100%问题快速定位实践</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>功能问题，通过日志，单步调试相对比较好定位。</p>
<p>性能问题，例如线上<a href="https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">服务器</a> CPU100%，如何找到相关服务，如何定位问题代码，更考验技术人的功底。</p>
<p>58 到家架构部，运维部，58 速运<a href="https://www.baidu.com/s?wd=%E6%8A%80%E6%9C%AF%E9%83%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">技术部</a>联合进行了一次线上服务 CPU 问题排查实战演练，同学们反馈有收获，特将实战演练的试题和答案公布出来，希望对大家也有帮助。</p>
<p>题目</p>
<p>某服务器上部署了若干 tomcat 实例，即若干垂直切分的 Java 站点服务，以及若干 Java 微服务，突然收到运维的 CPU 异常告警。</p>
<p>问：如何定位是哪个服务进程导致 CPU 过载，哪个线程导致 CPU 过载，哪段代码导致 CPU 过载？</p>
<p>步骤一、找到最耗 CPU 的进程</p>
<p>工具：top</p>
<p>方法：</p>
<ul>
<li><p>执行 top -c ，显示进程运行信息列表</p>
</li>
<li><p>键入 P (大写 p)，进程按照 CPU 使用率排序</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155433936?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，最耗 CPU 的进程 PID 为 10765</p>
<p>步骤二：找到最耗 CPU 的线程</p>
<p>工具：top</p>
<p>方法：</p>
<ul>
<li><p>top -Hp 10765 ，显示一个进程的线程运行信息列表</p>
</li>
<li><p>键入 P (大写 p)，线程按照 CPU 使用率排序</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155519686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，进程 10765 内，最耗 CPU 的线程 PID 为 10804</p>
<p>步骤三：将线程 PID 转化为 16 进制</p>
<p>工具：printf</p>
<p>方法：printf “%x\n” 10804</p>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155607290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，10804 对应的 16 进制是 0x2a34，当然，这一步可以用计算器。</p>
<p>之所以要转化为 16 进制，是因为堆栈里，线程 id 是用 16 进制表示的。</p>
<p>步骤四：查看堆栈，找到线程在干嘛</p>
<p>工具：pstack/jstack/grep</p>
<p>方法：jstack 10765 | grep ‘0x2a34’ -C5 –color</p>
<ul>
<li><p>打印进程堆栈</p>
</li>
<li><p>通过线程 id，过滤得到线程堆栈</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155648798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，找到了耗 CPU 高的线程对应的线程名称 “AsyncLogger-1”，以及看到了该线程正在执行代码的堆栈。</p>
<p>希望对经常进行线上 CPU 问题排查的同学有帮助，如果有更好的实践，也欢迎分享。</p>
<p>想要印象深刻，请大家务必线上实操练习哟。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/如何优雅的使用和理解线程池/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/如何优雅的使用和理解线程池/" class="post-title-link" itemprop="url">如何优雅的使用和理解线程池</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808901?w=766&amp;h=136" alt=""></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<ul>
<li>线程是稀缺资源，不能频繁的创建。</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>应当将其放入一个池子中，可以给其他任务进行复用。</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
<li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
<li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>
<p>其实看这三种方式创建的源码就会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>
<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(new Job());</span><br></pre></td></tr></table></figure>
<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808902?w=707&amp;h=126" alt=""></p>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p>用图表示为：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808903?w=1033&amp;h=406" alt=""></p>
<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808904?w=754&amp;h=310" alt=""></p>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
<p>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808905?w=500&amp;h=293" alt=""></p>
<h3 id="如何配置线程"><a href="#如何配置线程" class="headerlink" title="如何配置线程"></a>如何配置线程</h3><p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2</li>
<li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>
<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<blockquote>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt;= 5; i++) &#123;</span><br><span class="line">    pool.execute(new Job());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line">while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(&quot;线程还在执行。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start));</span><br></pre></td></tr></table></figure>
<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><blockquote>
<p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>
<p>如果我们很多业务都依赖于同一个线程池, 当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>
<p>通常的做法是按照业务进行划分：</p>
<blockquote>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h3><p>这样的需求 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a> 已经帮我们实现了。</p>
<blockquote>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>
<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Function:订单服务</span><br><span class="line"> *</span><br><span class="line"> * @author crossoverJie</span><br><span class="line"> *         Date: 2018/7/28 16:43</span><br><span class="line"> * @since JDK 1.8</span><br><span class="line"> */</span><br><span class="line">public class CommandOrder extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);</span><br><span class="line"></span><br><span class="line">    private String orderName;</span><br><span class="line"></span><br><span class="line">    public CommandOrder(String orderName) &#123;</span><br><span class="line"></span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                //服务分组</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;))</span><br><span class="line">                //线程分组</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;))</span><br><span class="line"></span><br><span class="line">                //线程池配置</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(10)</span><br><span class="line">                        .withKeepAliveTimeMinutes(5)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(10000))</span><br><span class="line"></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;orderName=[&#123;&#125;]&quot;, orderName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        return &quot;OrderName=&quot; + orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Function:用户服务</span><br><span class="line"> *</span><br><span class="line"> * @author crossoverJie</span><br><span class="line"> *         Date: 2018/7/28 16:43</span><br><span class="line"> * @since JDK 1.8</span><br><span class="line"> */</span><br><span class="line">public class CommandUser extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public CommandUser(String userName) &#123;</span><br><span class="line"></span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                //服务分组</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;))</span><br><span class="line">                //线程分组</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;))</span><br><span class="line"></span><br><span class="line">                //线程池配置</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(10)</span><br><span class="line">                        .withKeepAliveTimeMinutes(5)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(10000))</span><br><span class="line"></span><br><span class="line">                //线程池隔离</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;userName=[&#123;&#125;]&quot;, userName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        return &quot;userName=&quot; + userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    CommandOrder commandPhone = new CommandOrder(&quot;手机&quot;);</span><br><span class="line">    CommandOrder command = new CommandOrder(&quot;电视&quot;);</span><br><span class="line"></span><br><span class="line">    //阻塞方式执行</span><br><span class="line">    String execute = commandPhone.execute();</span><br><span class="line">    LOGGER.info(&quot;execute=[&#123;&#125;]&quot;, execute);</span><br><span class="line"></span><br><span class="line">    //异步非阻塞方式</span><br><span class="line">    Future&lt;String&gt; queue = command.queue();</span><br><span class="line">    String value = queue.get(200, TimeUnit.MILLISECONDS);</span><br><span class="line">    LOGGER.info(&quot;value=[&#123;&#125;]&quot;, value);</span><br><span class="line"></span><br><span class="line">    CommandUser commandUser = new CommandUser(&quot;张三&quot;);</span><br><span class="line">    String name = commandUser.execute();</span><br><span class="line">    LOGGER.info(&quot;name=[&#123;&#125;]&quot;, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808909?w=928&amp;h=160" alt=""></p>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<blockquote>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>
<p>通过刚才的构造函数也能证明：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808910?w=1104&amp;h=334" alt=""></p>
<p>还要注意的一点是：</p>
<blockquote>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 <code>This instance can only be executed once. Please instantiate a new instance.</code> 异常。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>
<p>文末的 hystrix 源码：<br><a href="https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix" target="_blank" rel="noopener">https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  

  <article class="post post-type-normal post-sticky" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/蓄水池抽样算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="woo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Woo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="Sticky">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                
                <a href="/2018/11/02/蓄水池抽样算法/" class="post-title-link" itemprop="url">蓄水池抽样算法（Reservoir Sampling）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-02 22:11:29" itemprop="dateCreated datePublished" datetime="2018-11-02T22:11:29+01:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-02 22:24:55" itemprop="dateModified" datetime="2019-02-02T22:24:55+01:00">2019-02-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="蓄水池抽样算法（Reservoir-Sampling）"><a href="#蓄水池抽样算法（Reservoir-Sampling）" class="headerlink" title="蓄水池抽样算法（Reservoir Sampling）"></a>蓄水池抽样算法（Reservoir Sampling）</h1><p>许多年以后，当听说蓄水池抽样算法时,将会想起，那个小学数学老师带他做 “小明对水池边加水边放水，求何时能加满水” 应用题的下午。</p>
<h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>我是在一次失败的面试经历中听说蓄水池算法的。之后上网搜了搜，知道是一个数据抽样算法，寥寥几行，却暗藏玄机。主要用来解决如下问题。</p>
<p><strong>给定一个数据流，数据流长度 N 很大，且 N 直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出 m 个不重复的数据。</strong></p>
<p>这个场景强调了 3 件事：</p>
<ol>
<li>数据流长度 N 很大且不可知，所以不能一次性存入内存。</li>
<li>时间复杂度为 O(N)。</li>
<li>随机选取 m 个数，每个数被选中的概率为 m/N。</li>
</ol>
<p>第 1 点限制了不能直接取 N 内的 m 个随机数，然后按索引取出数据。第 2 点限制了不能先遍历一遍，然后分块存储数据，再随机选取。第 3 点是数据选取绝对随机的保证。讲真，在不知道蓄水池算法前，我想破脑袋也不知道该题做何解。</p>
<h2 id="二、核心代码及原理"><a href="#二、核心代码及原理" class="headerlink" title="二、核心代码及原理"></a>二、核心代码及原理</h2><p>蓄水池抽样算法的核心如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[] reservoir = new int[m];</span><br><span class="line"></span><br><span class="line">// init</span><br><span class="line">for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    reservoir[i] = dataStream[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = m; i &lt; dataStream.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    // 随机获得一个[0, i]内的随机整数</span><br><span class="line">    int d = rand.nextInt(i + 1);</span><br><span class="line">    // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素</span><br><span class="line">    if (d &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        reservoir[d] = dataStream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>这里使用已知长度的数组 dataStream 来表示未知长度的数据流，并假设数据流长度大于蓄水池容量 m。</p>
<p>算法思路大致如下：</p>
<ol>
<li>如果接收的数据量小于 m，则依次放入蓄水池。</li>
<li>当接收到第 i 个数据时，i &gt;= m，在 [0, i] 范围内取以随机数 d，若 d 的落在 [0, m-1] 范围内，则用接收到的第 i 个数据替换蓄水池中的第 d 个数据。</li>
<li>重复步骤 2。</li>
</ol>
<p>算法的精妙之处在于：<strong>当处理完所有的数据时，蓄水池中的每个数据都是以 m/N 的概率获得的。</strong></p>
<p>下面用白话文推导验证该算法。假设数据开始编号为 1.</p>
<p><strong>第 i 个接收到的数据最后能够留在蓄水池中的概率</strong> = <strong>第 i 个数据进入过蓄水池的概率</strong> * <strong>之后第 i 个数据不被替换的概率</strong>（第 i+1 到第 N 次处理数据都不会被替换）。</p>
<ol>
<li>当 i&lt;=m 时，数据直接放进蓄水池，所以<strong>第 i 个数据进入过蓄水池的概率 = 1</strong>。</li>
<li>当 i&gt;m 时，在 [1,i] 内选取随机数 d，如果 d&lt;=m，则使用第 i 个数据替换蓄水池中第 d 个数据，因此<strong>第 i 个数据进入过蓄水池的概率 = m/i</strong>。</li>
<li>当 i&lt;=m 时，程序从接收到第 m+1 个数据时开始执行替换操作，第 m+1 次处理会替换池中数据的为 m/(m+1)，会替换掉第 i 个数据的概率为 1/m，则第 m+1 次处理替换掉第 i 个数据的概率为 (m/(m+1))<em>(1/m)=1/(m+1)，不被替换的概率为 1-1/(m+1)=m/(m+1)。依次，第 m+2 次处理不替换掉第 i 个数据概率为 (m+1)/(m+2)… 第 N 次处理不替换掉第 i 个数据的概率为 (N-1)/N。所以，之后**第 i 个数据不被替换的概率 = m/(m+1)</em>(m+1)/(m+2)<em>…</em>(N-1)/N=m/N**。</li>
<li>当 i&gt;m 时，程序从接收到第 i+1 个数据时开始有可能替换第 i 个数据。则参考上述第 3 点，<strong>之后第 i 个数据不被替换的概率 = i/N</strong>。</li>
<li>结合第 1 点和第 3 点可知，当 i&lt;=m 时，第 i 个接收到的数据最后留在蓄水池中的概率 = 1<em>m/N=m/N。结合第 2 点和第 4 点可知，当 i&gt;m 时，第 i 个接收到的数据留在蓄水池中的概率 = m/i</em>i/N=m/N。综上可知，<strong>每个数据最后被选中留在蓄水池中的概率为 m/N</strong>。</li>
</ol>
<p>这个算法建立在统计学基础上，很巧妙地获得了 “m/N” 这个概率。</p>
<h2 id="三、深入一些——分布式蓄水池抽样（Distributed-Parallel-Reservoir-Sampling）"><a href="#三、深入一些——分布式蓄水池抽样（Distributed-Parallel-Reservoir-Sampling）" class="headerlink" title="三、深入一些——分布式蓄水池抽样（Distributed/Parallel Reservoir Sampling）"></a>三、深入一些——分布式蓄水池抽样（Distributed/Parallel Reservoir Sampling）</h2><p>一块 CPU 的计算能力再强，也总有内存和磁盘 IO 拖他的后腿。因此为提高数据吞吐量，分布式的硬件搭配软件是现在的主流。</p>
<p>如果遇到超大的数据量，即使是 O(N) 的时间复杂度，蓄水池抽样程序完成抽样任务也将耗时很久。因此分布式的蓄水池抽样算法应运而生。运作原理如下：</p>
<ol>
<li>假设有 K 台机器，将大数据集分成 K 个数据流，每台机器使用单机版蓄水池抽样处理一个数据流，抽样 m 个数据，并最后记录处理的数据量为 N1, N2, …, Nk, …, NK(假设 m&lt;Nk)。N1+N2+…+NK=N。</li>
<li>取 [1, N] 一个随机数 d，若 d&lt;N1，则在第一台机器的蓄水池中等概率不放回地（1/m）选取一个数据；若 N1&lt;=d&lt;(N1+N2)，则在第二台机器的蓄水池中等概率不放回地选取一个数据；一次类推，重复 m 次，则最终从 N 大数据集中选出 m 个数据。</li>
</ol>
<p>m/N 的概率验证如下：</p>
<ol>
<li>第 k 台机器中的蓄水池数据被选取的概率为 m/Nk。</li>
<li>从第 k 台机器的蓄水池中选取一个数据放进最终蓄水池的概率为 Nk/N。</li>
<li>第 k 台机器蓄水池的一个数据被选中的概率为 1/m。（不放回选取时等概率的）</li>
<li>重复 m 次选取，则每个数据被选中的概率为 <strong>m<em>(m/Nk</em>Nk/N*1/m)=m/N</strong>。</li>
</ol>
<h2 id="四、算法验证"><a href="#四、算法验证" class="headerlink" title="四、算法验证"></a>四、算法验证</h2><p>写一份完整的代码，用来验证蓄水池抽样的随机性。数据集大小为 1000，蓄水池容量为 10，做 10_0000 次抽样。如果程序正确，那么每个数被抽中的次数接近 1000 次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.njupt.qyz;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">public class ReservoirSampling &#123;</span><br><span class="line"></span><br><span class="line">    static ExecutorService exec = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">    // 抽样任务，用作模拟并行抽样</span><br><span class="line">    private static class SampleTask implements Callable&lt;int[]&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // 输入该任务的数据</span><br><span class="line">        private int[] innerData;</span><br><span class="line">        // 蓄水池容量</span><br><span class="line">        private int m;</span><br><span class="line"></span><br><span class="line">        SampleTask (int m, int[] innerData)</span><br><span class="line">        &#123;</span><br><span class="line">            this.innerData = innerData;</span><br><span class="line">            this.m = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int[] call() throws Exception</span><br><span class="line">        &#123;</span><br><span class="line">            int[] reservoir = sample(this.m, this.innerData);</span><br><span class="line">            return reservoir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 并行抽样</span><br><span class="line">    public static int[] mutiSample(int m, int[] dataStream) throws InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line"></span><br><span class="line">        int[] reservoir = initReservoir(m, dataStream);</span><br><span class="line"></span><br><span class="line">        // 生成3个范围内随机数，将数据切成4份</span><br><span class="line">        List&lt;Integer&gt; list = getRandInt(rand, dataStream.length); </span><br><span class="line">        int s1 = list.get(0);</span><br><span class="line">        int s2 = list.get(1);</span><br><span class="line">        int s3 = list.get(2);</span><br><span class="line">        // 每个任务处理的数据量</span><br><span class="line">        double n1 = s1 - 0;</span><br><span class="line">        double n2 = s2 - s1;</span><br><span class="line">        double n3 = s3 - s2;</span><br><span class="line">        double n4 = dataStream.length - s3;</span><br><span class="line"></span><br><span class="line">        // 并行抽样</span><br><span class="line">        Future&lt;int[]&gt; f1 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, 0, s1)));</span><br><span class="line">        Future&lt;int[]&gt; f2 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, s1, s2)));</span><br><span class="line">        Future&lt;int[]&gt; f3 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, s2, s3)));</span><br><span class="line">        Future&lt;int[]&gt; f4 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, s3, dataStream.length)));</span><br><span class="line">        List&lt;Integer&gt; r1 = getList(f1.get());</span><br><span class="line">        List&lt;Integer&gt; r2 = getList(f2.get());</span><br><span class="line">        List&lt;Integer&gt; r3 = getList(f3.get());</span><br><span class="line">        List&lt;Integer&gt; r4 = getList(f4.get());</span><br><span class="line"></span><br><span class="line">        // 进行m次抽样</span><br><span class="line">        for (int i = 0; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int p = rand.nextInt(dataStream.length);</span><br><span class="line">            // 根据随机数落在的范围选择元素</span><br><span class="line">            if (p &lt; s1)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r1, rand.nextInt(r1.size()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p &lt; s2)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r2, rand.nextInt(r2.size()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p &lt; s3)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r3, rand.nextInt(r3.size()));</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r4, rand.nextInt(r4.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return reservoir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据输入返回随机位置的元素，并且删除该元素，模拟不放回</span><br><span class="line">    private static int getRandEle(List&lt;Integer&gt; list, int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        return list.remove(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取bound范围内的3个随机数，用来分割数据集</span><br><span class="line">    private static List&lt;Integer&gt; getRandInt(Random rand, int bound)</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        while (set.size() &lt; 3)</span><br><span class="line">        &#123;</span><br><span class="line">            set.add(rand.nextInt(bound));</span><br><span class="line">        &#125;</span><br><span class="line">        for (int e: set)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    // 数据转换成List</span><br><span class="line">    private static List&lt;Integer&gt; getList(int[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int a : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单机版蓄水池抽样</span><br><span class="line">    public static int[] sample(int m, int[] dataStream)</span><br><span class="line">    &#123;</span><br><span class="line">        // 随机数生成器，以系统当前nano时间作为种子</span><br><span class="line">        Random rand = new Random();</span><br><span class="line"></span><br><span class="line">        int[] reservoir = initReservoir(m, dataStream);</span><br><span class="line"></span><br><span class="line">        // init</span><br><span class="line">        for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            reservoir[i] = dataStream[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = m; i &lt; dataStream.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 随机获得一个[0, i]内的随机整数</span><br><span class="line">            int d = rand.nextInt(i + 1);</span><br><span class="line">            // 如果随机整数在[0, m-1]范围内，则替换蓄水池中的元素</span><br><span class="line">            if (d &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[d] = dataStream[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reservoir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int[] initReservoir (int m, int[] dataStream)</span><br><span class="line">    &#123;</span><br><span class="line">        int[] reservoir;</span><br><span class="line"></span><br><span class="line">        if (m &gt; dataStream.length)</span><br><span class="line">        &#123;</span><br><span class="line">            reservoir = new int[dataStream.length];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            reservoir = new int[m];</span><br><span class="line">        &#125;</span><br><span class="line">        return reservoir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单机版测试</span><br><span class="line">    public void test()</span><br><span class="line">    &#123;</span><br><span class="line">        // 样本长度</span><br><span class="line">        int len = 1000;</span><br><span class="line">        // 蓄水池容量</span><br><span class="line">        int m = 10;</span><br><span class="line">        // 抽样次数，用作验证抽样的随机性</span><br><span class="line">        int iterTime = 100000;</span><br><span class="line">        // 每个数字被抽到的次数</span><br><span class="line">        int[] freq = new int[len];</span><br><span class="line">        // 样本</span><br><span class="line">        int[] dataStream = new int[len];</span><br><span class="line"></span><br><span class="line">        // init dataStream</span><br><span class="line">        for (int i = 0; i &lt; dataStream.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dataStream[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // count freq</span><br><span class="line">        for (int k = 0; k &lt; iterTime; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 进行抽样</span><br><span class="line">            int[] reservoir = sample(m, dataStream);</span><br><span class="line">            // 计算出现次数</span><br><span class="line">            for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int ele = reservoir[i];</span><br><span class="line">                freq[ele] += 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printStaticInfo(freq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试并行抽样</span><br><span class="line">    public void mutiTest() throws InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        // 样本长度</span><br><span class="line">        int len = 1000;</span><br><span class="line">        // 蓄水池容量</span><br><span class="line">        int m = 10;</span><br><span class="line">        // 抽样次数，用作验证抽样的随机性</span><br><span class="line">        int iterTime = 10_0000;</span><br><span class="line">        // 每个数字被抽到的次数</span><br><span class="line">        int[] freq = new int[len];</span><br><span class="line">        // 样本</span><br><span class="line">        int[] dataStream = new int[len];</span><br><span class="line"></span><br><span class="line">        // init dataStream</span><br><span class="line">        for (int i = 0; i &lt; dataStream.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dataStream[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // count freq</span><br><span class="line">        for (int k = 0; k &lt; iterTime; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 进行抽样</span><br><span class="line">            int[] reservoir = mutiSample(m, dataStream);</span><br><span class="line">            // 计算出现次数</span><br><span class="line">            for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int ele = reservoir[i];</span><br><span class="line">                freq[ele] += 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printStaticInfo(freq);</span><br><span class="line">    &#125;</span><br><span class="line">    // 打印统计信息</span><br><span class="line">    private void printStaticInfo (int[] freq)</span><br><span class="line">    &#123;</span><br><span class="line">        // 期望、方差和标准差</span><br><span class="line">        double avg = 0;</span><br><span class="line">        double var = 0;</span><br><span class="line">        double sigma = 0;</span><br><span class="line">        // print</span><br><span class="line">        for (int i = 0; i &lt; freq.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i % 10 == 9) System.out.println();</span><br><span class="line">            System.out.print(freq[i] + &quot;, &quot;);</span><br><span class="line">            avg += ((double)(freq[i]) / freq.length);</span><br><span class="line">            var += (double)(freq[i] * freq[i]) / freq.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 输出统计信息</span><br><span class="line">        System.out.println(&quot;\n===============================&quot;);</span><br><span class="line">        var = var - avg * avg;</span><br><span class="line">        sigma = Math.sqrt(var);</span><br><span class="line">        System.out.println(&quot;Average: &quot; + avg);</span><br><span class="line">        System.out.println(&quot;Variance: &quot; + var);</span><br><span class="line">        System.out.println(&quot;Standard deviation: &quot; + sigma);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) throws InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        ReservoirSampling rs = new ReservoirSampling();</span><br><span class="line">        rs.mutiTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单机版输出和并行版的输出类似，截取片段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">948, 1006, 1014, 1019, 1033, 1040, 948, 1014, 1000, 951, </span><br><span class="line">1014, 987, 1049, 1043, 1034, 983, 1006, 974, 1060, 1009, </span><br><span class="line">986, 1021, 1024, 963, 1041, 1028, 988, 1011, 975, 980, </span><br><span class="line">1055, 1017, 1010, 1018, 1013, 983, 942, 1056, 1003, 1063, </span><br><span class="line">1004, 1004, 999, 976, 957, 935, 1061, 1018, 1002, 1018, </span><br><span class="line">1019, 946, 985, 1057, 1012, 965, 978, 1040, 1026, 1064, </span><br><span class="line">1026, 1018, 980, 996, 1025, 1028, 1006, 944, 986, 981, </span><br><span class="line">923, 1015, 991, 1019, 1024, 1143, 989, 985, 1022, 1019, </span><br><span class="line">1004, 1000, 989, 972, 1041, 988, 1050, 932, 975, 1037, </span><br><span class="line">1016, 983, 1051, 1003, 983, 986, 1017, 1009, 936, 993, </span><br><span class="line">965, 976, 1001, 1000, 988, 1030, 1050, 1024, 981, 985, </span><br><span class="line">935, 1023, 996, 1007, 1013, 1046, 1003, 1006, 973, 989, </span><br><span class="line">943, </span><br><span class="line">===============================</span><br><span class="line">Average: 1000.0000000000002</span><br><span class="line">Variance: 1011.8799999983748</span><br><span class="line">Standard deviation: 31.81006130139291</span><br></pre></td></tr></table></figure>
<p>此外，为了对比单机版与并行版（4 线程）的性能差异，使用 10_0000 大小的数据集，蓄水池容量 10，进行 100_0000 次重复抽样，对比两者的运行时间。结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---------单机版----------</span><br><span class="line"></span><br><span class="line">===============================</span><br><span class="line">Average: 100.00000000000125</span><br><span class="line">Variance: 100.31497999751264</span><br><span class="line">Standard deviation: 10.015736617818613</span><br><span class="line">---------并行版----------</span><br><span class="line"></span><br><span class="line">===============================</span><br><span class="line">Average: 100.00000000000169</span><br><span class="line">Variance: 100.63045999737915</span><br><span class="line">Standard deviation: 10.031473470900432</span><br><span class="line">单机版耗时：2006s</span><br><span class="line">并行版耗时：1265s</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，算法保证了数据选取的随机性。且并行版算法能够有效提高数据吞吐量。</p>
<h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><p>蓄水池抽样的 O(N) 时间复杂度，O(m) 空间复杂度令其适用于对流数据、大数据集的等概率抽样。比如一个大文本数据，随机输出其中的几行。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>象征性总结：优雅巧妙的算法——蓄水池抽样。</p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><ol>
<li><a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.jobbole.com%2F42550%2F" target="_blank" rel="noopener">数据工程师必知算法：蓄水池抽样</a></li>
<li><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fpython27%2Fp%2FReservoir_Sampling_Algorithm.html" target="_blank" rel="noopener">【算法 34】蓄水池抽样算法 (Reservoir Sampling Algorithm)</a></li>
<li><a href="https://www.jianshu.com/p/eea05fb27e3f" target="_blank" rel="noopener">分布式 / 并行蓄水池抽样 (Distributed/Parallel Reservoir Sampling)</a></li>
<li><a href="https://link.jianshu.com?t=https%3A%2F%2Fballsandbins.wordpress.com%2F2014%2F04%2F13%2Fdistributedparallel-reservoir-sampling%2F" target="_blank" rel="noopener">Distributed/Parallel Reservoir Sampling</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">woo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">woo</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  



  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
