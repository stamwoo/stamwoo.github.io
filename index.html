<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Blog of Woo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Blog of Woo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog of Woo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog of Woo">
  
    <link rel="alternate" href="/atom.xml" title="Blog of Woo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog of Woo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TCP为什么是三次握手" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/02/TCP为什么是三次握手/" class="article-date">
  <time datetime="2019-02-02T20:45:46.372Z" itemprop="datePublished">2019-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP为什么是三次握手"><a href="#TCP为什么是三次握手" class="headerlink" title="TCP为什么是三次握手"></a>TCP为什么是三次握手</h1><p>TCP为什么建立连接是三次握手? 对于C和S来说,双方均需要确认对方和自己的发送信息能力和接受信息能力是OK的.<br>拿一次完整的三次握手来举例:   </p>
<ul>
<li>第一次握手:C和S什么都不能确认.</li>
<li>第二次握手:C确认了自己的发送能力和接受能力,S确认了自己的接受能力.</li>
<li>第三次握手:S确认了自己的发送能力.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/02/TCP为什么是三次握手/" data-id="cjrnyarc500029lkmfoih5rdy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql explain 详解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/02/mysql explain 详解/" class="article-date">
  <time datetime="2019-02-02T20:12:14.340Z" itemprop="datePublished">2019-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mysql-explain-详解"><a href="#mysql-explain-详解" class="headerlink" title="mysql explain 详解"></a><a href="#mysql-explain详解" title="mysql explain详解"></a>mysql explain 详解</h1><h2 id="语法及描述"><a href="#语法及描述" class="headerlink" title="语法及描述"></a><a href="#语法及描述" title="语法及描述"></a>语法及描述</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><a href="#语法" title="语法"></a>语法</h3><p>在 select 语句前加上 explain 关键字就可以</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="#描述" title="描述"></a>描述</h3><p>获取查询操作的执行顺序<br>使用到的索引<br>成功返回结果需要执行的行数</p>
<h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><p>###id<br>标识符, 表示执行顺序. id 一样则自上而下, 否则大的先执行.</p>
<p>###select_type<br>查询类型</p>
<ol>
<li>simple: 不包含 union 操作或者不包含子查询的简单 select 查询</li>
<li>primary: 需要 union 操作或者含有子查询的 select, 位于最外层的 select.type 即为 primary, 且只有一个.</li>
<li>union:union 链接的两个 select 查询, 第一个是 primiary, 第二个之后的都是 union.</li>
<li>Dependent union: 出现在 union 或 union all 语句, 但是这个查询要收到外部查询的影响.</li>
<li>union result: 包含 union 的结果集, 在 union 和 union all 语句中, 因为它不需要参与查询,, 所以 id 字段为 null</li>
<li>subquery: 除了 from 子句中包含的子查询外, 其他地方出现的子查询都可能是 subquery</li>
<li>Dependent subquery: 与 dependent union 类似, 表示这个 subquery 的查询要受到外部表查询的影响</li>
<li>derived:from 子句中出现的子查询, 也叫做派生表, 其他数据库中可能叫做内联师徒或嵌套 select</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>| </p>
<pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre>

<p> | </p>
<pre>//外层是primary,内层是subquery
explain select * from student s where s. classid = (select id from classes where classno='2017001');

//结果有三行,第一行是primary,第二行是union,第三行是union result
explain select * from student where id = 1 union select * from student where id = 2;

//结果有四行,分别是primary,dependent subquery,dependent union,union result
explain select * from student s where s.classid in (select id from classes where classno='2017001' union select id from classes where classno='2017002');

//跟mysql版本有关
explain select * from (select * from student) s;
table
显示查询语句所查询的表名,如果查询使用了别名,那么这里使用的是别名.如果不涉及对数据表的操作,显示为null;有一种特殊情况,如果显示为,,则都是临时表.M,N代表的id,表示结果来自于这个查询产生
</pre>

<p> |</p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a><a href="#partitions" title="partitions"></a>partitions</h3><p>表是分区表才行</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a><a href="#type" title="type"></a>type</h3><p>查询结果类型</p>
<ol>
<li>const: 返回结果只有一个匹配行</li>
<li>range: 索引范围扫描，常见于使用 &gt;,&lt;,is null,between ,in ,like 等运算符的查询中</li>
<li>index: 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</li>
<li>index_merge: 使用了一张表的多个索引, 实际上由于要读取所个索引，性能可能大部分时间都不如 range<br>全表扫描数据文件</li>
<li><p>possible_keys &amp; key<br>possible_keys: 查询可能使用到的索引都会在这里列出来。</p>
</li>
<li><p>key: 查询真正使用到的索引，select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个。</p>
</li>
<li><p>key_len<br>用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。</p>
</li>
</ol>
<p>留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h2><p>通过对上面 explain 中的每个字段的详细讲解。我们不难看出，对查询性能影响最大的几个列是：</p>
<ul>
<li>select_type：查询类型</li>
<li>type: 连接使用了何种类型</li>
<li>rows: 查询数据需要用到的行</li>
<li>key: 查询真正使用到的索引</li>
<li>extra: 额外的信息<br>尽量让自己的 SQL 用上索引，避免让 extra 里面出现 file sort(文件排序),using temporary(使用临时表)。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/02/mysql explain 详解/" data-id="cjrnyarc600039lkmz4d7ys3s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-为什么你需要一个 vps" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/02/为什么你需要一个 vps/" class="article-date">
  <time datetime="2019-02-02T20:11:46.981Z" itemprop="datePublished">2019-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="VPS-是什么"><a href="#VPS-是什么" class="headerlink" title="VPS 是什么"></a><a href="#VPS是什么" title="VPS是什么"></a>VPS 是什么</h1><p>VPS 是 Virtual private server 的简称，中文是 “虚拟专用服务器”，是指通过虚拟化技术在独立服务器中运行的专用服务器。每个使用 VPS 技术的虚拟独立服务器拥有各自独立的公网 IP 地址、操作系统、硬盘空间、内存空间、CPU 资源等，还可以进行安装程序、重启服务器等操作，与运行一台独立服务器基本相同。</p>
<p>很多人有点分不清 VPS 与虚拟主机的区别，网上也有很多人说过这个。博主这里就不长篇大论了，简单说，VPS 就相当于一台真正的电脑，只不过这台电脑是放在别人家的。你可以通过 ssh 工具对它做任何事，只要你开心，你砸了它也行。<br>而虚拟主机说到底是别人家的电脑借给你用，你可以使用上面的计算资源，虚拟主机的服务商已经给你提供各种安装好的工具以及计算资源。但你对它的权限是比不上 VPS 大的。</p>
<h1 id="VPS-可以用来做什么"><a href="#VPS-可以用来做什么" class="headerlink" title="VPS 可以用来做什么"></a><a href="#VPS可以用来做什么" title="VPS可以用来做什么"></a>VPS 可以用来做什么</h1><h2 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a><a href="#Shadowsocks" title="Shadowsocks"></a>Shadowsocks</h2><p>使用 Python、C++、C# 等语言开发、基于 Apache 许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks 使用 Socks5 代理方式。<br>Shadowsocks 分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。<br>其实关于在 vps 搭建 SS 的教程已经很多了，但是博主之前搭梯子的时候发现很多教程存在一些问题，或者是太繁琐，或者是很多重要地方过了一段时间已经发生了变化，对小白用户不太友好。</p>
<p>因此博主决定写一篇新的教程分享出来。</p>
<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a><a href="#Blog" title="Blog"></a>Blog</h2><p>搭建一个属于自己的博客，搭配上 github education 提供的工具包，还可以获得一个免费域名及 SSL 认证。博主这个博客既是使用我说的这种方案搭建的。过程十分简单，按照博主的上一篇教程：在自己的 VPS 上从零开始搭建 Hexo 博客, 半天时间即可搭建完成并上线。</p>
<h2 id="Seafile"><a href="#Seafile" class="headerlink" title="Seafile"></a><a href="#Seafile" title="Seafile"></a>Seafile</h2><p>一套中国国产的开源、专业、可靠的云存储项目管理软件，[解决文件集中存储、共享和跨平台访问等问题。正式发布于 2012 年 10 月。除了一般网盘所提供的云存储以及共享功能外，Seafile 还提供消息通信、群组讨论等辅助功能，帮助员工更好的围绕文件展开协同工作，已有 10 多万用户使用。</p>
<p>作为一套比较成熟的管理软件，Seafile 的安装也十分简单。Install Seafile Client on Linux</p>
<p>此外，你还可以在 VPS 部署更多你自己写的脚本，比如爬虫类工具，抢票程序等等。一句话，只要是你的程序有 7*24h 的服务时间需求，你都可以把它放在你的 VPS 上跑。</p>
<h1 id="VPS-哪家强"><a href="#VPS-哪家强" class="headerlink" title="VPS 哪家强"></a><a href="#VPS哪家强" title="VPS哪家强"></a>VPS 哪家强</h1><p>看了上面的内容，如果你想选择一家 VPS 提供商，那么你大概有哪些选择呢？博主也给出了当下比较流行，有口碑的 VPS 服务商供大家参考。</p>
<h2 id="DigitalOcean"><a href="#DigitalOcean" class="headerlink" title="DigitalOcean"></a><a href="#DigitalOcean" title="DigitalOcean"></a>DigitalOcean</h2><p>一家位于美国的云主机服务商，总部位于纽约，成立于 2012 年。由于价格低廉，高性能配置、灵活布置的优势，近些年来发展迅猛，成为中国站长圈们喜爱的品牌。该公司拥有多个数据中心：日本东京、美国 洛杉矶、纽约、新泽西、新加坡、英国伦敦、德国富兰克林.</p>
<p>DigitailOcean，博主习惯称为 DO。也是博主选择的第一家 VPS 服务商，对于博主这种学生党而言，DO 是最具有性价比的一家服务商，由邀请链接注册自动赠送 $10 的优惠，再通过 paypal 充值 $5 即可使用。如果是学生用户的话使用 github education 提供的学生开发包可以再获得 $50 的优惠码。也就是说 $5 就可以使用 DO 的 1G 25gSSD 的 VPS 长达 13 个月，这性价比也是没谁了吧。</p>
<p>我的邀请链接是：$10 邀请链接, 另外为了选择合适的机房，再贴一个测速链接：SFO2 Speedtest | DigitalOcean</p>
<h2 id="Linode"><a href="#Linode" class="headerlink" title="Linode"></a><a href="#Linode" title="Linode"></a>Linode</h2><p>一个建立于美国新泽西州加洛伟的虚拟专用服务器（VPS）提供商。它的名字是由英文中 Linux 中的 Li 和 node（即 “节点” 一词）构成的混成词。如同它的名字一样，Linode 只提供运行 Linux 的服务器，而不提供运行 Windows Server 的服务器。它的服务一向以稳定著称。</p>
<p>知乎在发展初期使用的就是 Linode 的服务，现在口碑比较好的比较稳定的就是日本机房了，不过是要抢购，基本每每放出来都被抢完了。</p>
<h2 id="搬瓦工"><a href="#搬瓦工" class="headerlink" title="搬瓦工"></a><a href="#搬瓦工" title="搬瓦工"></a>搬瓦工</h2><p>隶属于加拿大 IT7 旗下的 VPS 服务品牌，主推 OPENVZ 架构方案，尤其是其中的 4 款便宜年付 VPS 深受广大用户的喜欢，支持支付宝付款，旗下有四个机房，均支持一键切换机房位置以及一键安装各类软件等功能。</p>
<p>这家前些年应该是最火的 vps 服务商了，记得曾经有 $5 的年 vps，小内存搭个 ss 还是很够用的。后来因为 ip 资源枯竭，搬瓦工拿不到什么 ip 就停了自家的超低资费服务。不过现在还是有 $19.99 的资费可以选。</p>
<h2 id="Vultr"><a href="#Vultr" class="headerlink" title="Vultr"></a><a href="#Vultr" title="Vultr"></a>Vultr</h2><p>一家 2014 年刚成立的 VPS 服务商，基于 KVM，采用 SSD 硬盘，拥有大量自建机房。有日本、美国洛杉矶、Dallas、Chicago、New York、Seattle、Atlanta、英国、德国等，价格便宜，配置又高。支持 Paypal、信用卡或比特币付款。</p>
<p>这家比较好的依然是日本主机，国内 ping 值在 100 以内，也较少抽风。另外他家的最低配置也比别家高，价格嘛，自然就水涨船高了。博主作为一个学生党目前觉得还没太必要用他家，以后说不定想试一试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/02/为什么你需要一个 vps/" data-id="cjrnyarc700049lkm44a58ztb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring boot 扫描不到自定义 Controller" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/31/spring boot 扫描不到自定义 Controller/" class="article-date">
  <time datetime="2019-01-31T15:18:20.173Z" itemprop="datePublished">2019-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 springboot 官网照着给的介绍写了个 springboot 程序</p>
<p>pom.xml</p>
<pre><parent>
    <groupid>org.springframework.boot</groupid>
    <artifactid>spring-boot-starter-parent</artifactid>
    <version>1.5.2.RELEASE</version>
</parent>
<dependencies>
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-web</artifactid>
    </dependency>
</dependencies></pre>

<p>java 文件</p>
<pre>package hello;

import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.stereotype.*;
import org.springframework.web.bind.annotation.*;

@Controller
@EnableAutoConfiguration
public class Application{

    @RequestMapping("/")
    @ResponseBody
    String home() {
        return "Hello World!";
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(SampleController.class, args);
    }
}</pre>

<p>然后自己写了个 Controller</p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409005618644-1487234010.png" alt=""></p>
<p>但是无论如何也无法扫描到自己定义的 Controller（如果用的是 idea，能明显看出来，如果扫描到会有<img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409005713894-1428437850.png" alt="">的图标）。访问结果结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409005517644-1213300216.png" alt=""></p>
<p>报错的原因是找不到对应的映射路径，即 Controller 没有被扫描到 ，。</p>
<p>郁闷至极，到晚上搜的结果说的是 LoginController 方的位置不对，应该让启动类和 Controller 的包在同一级目录下，然而对我却没有效果。</p>
<p>官方建议 application.java 放的位置：</p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409004634847-1050076443.png" alt=""></p>
<p>最后尝试了下修改下 Application 上的注解，<strong>我本来复制官方的代码用的是 @Controller 和 <em>@EnableAutoConfiguration，试着换成了 @</em>**</strong>SpringBootApplication<strong> </strong>注解**，出乎意外的可以扫描到 Controller </p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409010006191-38718118.png" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409010021238-427644219.png" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/997786/201704/997786-20170409010114410-919234476.png" alt=""></p>
<p>又查了下官方的文档终于找到原因了，原因是：</p>
<p>如果使用 @Controller 和 <em>@EnableAutoConfiguration 注解还应该再加上一个注解：</em>@ComponentScan  就可以了。@Controller 和 @EnableAutoConfiguration 没有扫描注解的功能，而 @ComponentScan 是</p>
<p> springboot 专门用来扫描 @Component, @Service, @Repository, @Controller 等注解的注解</p>
<p>总结：</p>
<p>使用 springboot 启动类配置扫描的两种注解配置方式：</p>
<p>1、@Controller</p>
<p> @EnableAutoConfiguration</p>
<p> @ComponentScan</p>
<p>2、@SpringBootApplication</p>
<p>@SpringBootApplication 注解等价于 @Configuration, @EnableAutoConfiguration and @ComponentScan</p>
<pre>另外application.java（启动类）也应该按照官方的建议放在root目录下，这样才能扫描到Service和dao，不然还会引起，扫描不到注解的问题。
**--- 更新日期：2018-10-14 ---**
最近用了最新的springboot 2.0.5.RELEASE 版本 多了一种新的扫描注解，新版的springboot application可以放在任意位置，只要加上</pre>

<p><pre>@ComponentScan(basePackages = {“com.oskyhang”, “com.frames”})</pre></p>
<p>注解就可以，注解指定扫描的包，就可以扫描到，更灵活方便。</p>
<p> PS：如有疑问或错误，欢迎指教。3Q</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/31/spring boot 扫描不到自定义 Controller/" data-id="cjrnyarc300019lkml3zwaeuy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringCloud 警告 (Eureka)：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE." class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/31/SpringCloud 警告 (Eureka)：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE./" class="article-date">
  <time datetime="2019-01-31T14:59:30.445Z" itemprop="datePublished">2019-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/gudi/p/8645370.html" target="_blank" rel="noopener">https://www.cnblogs.com/gudi/p/8645370.html</a></p>
</blockquote>
<p><strong>警告！Eureka 可能存在维护了错误的实例列表（当它们没有启动的时候，Eureka 却把它当成启动的了）；Renews 值小于 Threshold 值，因此剩下未过期的都是安全的。</strong></p>
<p><strong>原因分析：</strong></p>
<p>这个是 Eureka 的自我保护机制。Eureka Server 在运行期间，会统计心跳失败的比例在 15 分钟之内是否低于 85%，如果出现低于的情况（在单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳定导致），Eureka Server 会将当前的实例注册信息保护起来，同时提示这个警告。</p>
<p>Eureka server 和 client 之间每隔 30 秒会进行一次心跳通信，告诉 server，client 还活着。由此引出两个名词：<br>Renews threshold：server 期望在每分钟中收到的心跳次数<br>Renews (last min)：上一分钟内收到的心跳次数。</p>
<p>前文说到禁止注册 server 自己为 client，不管 server 是否禁止，阈值（threshold）是 1。client 个数为 n，阈值为 1+2<em>n（此为一个 server 且禁止自注册的情况）<br>如果是多个 server，且开启了自注册，那么就和 client 一样，是对于其他的 server 来说就是 client，是要 </em> 2 的</p>
<p>我开了两个 server，自注册，相关数据如下<br><img src="http://img.blog.csdn.net/20170418001242248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenpwNDQ4NTYxNjM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>阈值：1+2<em>1<br>renews：<br>1）自注册 2 + 2</em>1<br>2）非自注册：2*1</p>
<p>Eurake 有一个配置参数 eureka.server.renewalPercentThreshold，定义了 renews 和 renews threshold 的比值，默认值为 0.85。当 server 在 15 分钟内，比值低于 percent，即少了 15% 的微服务心跳，server 会进入自我保护状态，Self-Preservation。在此状态下，server 不会删除注册信息，这就有可能导致在调用微服务时，实际上服务并不存在。<br>这种保护状态实际上是考虑了 client 和 server 之间的心跳是因为网络问题，而非服务本身问题，不能简单的删除注册信息</p>
<p>stackoverflow 上，有人给出的建议是：<br>1、在生产上可以开自注册，部署两个 server<br>2、在本机器上测试的时候，可以把比值调低，比如 0.49<br>3、或者简单粗暴把自我保护模式关闭</p>
<pre>**`eureka.server.enableSelfPreservation=false`**</pre>

<p><strong> 参考文档</strong></p>
<p><a href="https://www.cnblogs.com/breath-taking/articles/7940364.html" target="_blank" rel="noopener">https://www.cnblogs.com/breath-taking/articles/7940364.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/31/SpringCloud 警告 (Eureka)：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE./" data-id="cjrnyarbu00009lkmv21ccabb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-蓄水池抽样算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/29/蓄水池抽样算法/" class="article-date">
  <time datetime="2019-01-29T22:29:09.267Z" itemprop="datePublished">2019-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="蓄水池抽样算法（Reservoir-Sampling）"><a href="#蓄水池抽样算法（Reservoir-Sampling）" class="headerlink" title="蓄水池抽样算法（Reservoir Sampling）"></a>蓄水池抽样算法（Reservoir Sampling）</h1><p>许多年以后，当听说蓄水池抽样算法时，邱 simple 将会想起，那个小学数学老师带他做 “小明对水池边加水边放水，求何时能加满水” 应用题的下午。</p>
<h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>我是在一次失败的面试经历中听说蓄水池算法的。之后上网搜了搜，知道是一个数据抽样算法，寥寥几行，却暗藏玄机。主要用来解决如下问题。</p>
<p><strong>给定一个数据流，数据流长度 N 很大，且 N 直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出 m 个不重复的数据。</strong></p>
<p>这个场景强调了 3 件事：</p>
<ol>
<li>数据流长度 N 很大且不可知，所以不能一次性存入内存。</li>
<li>时间复杂度为 O(N)。</li>
<li>随机选取 m 个数，每个数被选中的概率为 m/N。</li>
</ol>
<p>第 1 点限制了不能直接取 N 内的 m 个随机数，然后按索引取出数据。第 2 点限制了不能先遍历一遍，然后分块存储数据，再随机选取。第 3 点是数据选取绝对随机的保证。讲真，在不知道蓄水池算法前，我想破脑袋也不知道该题做何解。</p>
<h2 id="二、核心代码及原理"><a href="#二、核心代码及原理" class="headerlink" title="二、核心代码及原理"></a>二、核心代码及原理</h2><p>蓄水池抽样算法的核心如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[] reservoir = new int[m];</span><br><span class="line"></span><br><span class="line">// init</span><br><span class="line">for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    reservoir[i] = dataStream[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = m; i &lt; dataStream.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    // 随机获得一个[0, i]内的随机整数</span><br><span class="line">    int d = rand.nextInt(i + 1);</span><br><span class="line">    // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素</span><br><span class="line">    if (d &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        reservoir[d] = dataStream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>这里使用已知长度的数组 dataStream 来表示未知长度的数据流，并假设数据流长度大于蓄水池容量 m。</p>
<p>算法思路大致如下：</p>
<ol>
<li>如果接收的数据量小于 m，则依次放入蓄水池。</li>
<li>当接收到第 i 个数据时，i &gt;= m，在 [0, i] 范围内取以随机数 d，若 d 的落在 [0, m-1] 范围内，则用接收到的第 i 个数据替换蓄水池中的第 d 个数据。</li>
<li>重复步骤 2。</li>
</ol>
<p>算法的精妙之处在于：<strong>当处理完所有的数据时，蓄水池中的每个数据都是以 m/N 的概率获得的。</strong></p>
<p>下面用白话文推导验证该算法。假设数据开始编号为 1.</p>
<p><strong>第 i 个接收到的数据最后能够留在蓄水池中的概率</strong> = <strong>第 i 个数据进入过蓄水池的概率</strong> * <strong>之后第 i 个数据不被替换的概率</strong>（第 i+1 到第 N 次处理数据都不会被替换）。</p>
<ol>
<li>当 i&lt;=m 时，数据直接放进蓄水池，所以<strong>第 i 个数据进入过蓄水池的概率 = 1</strong>。</li>
<li>当 i&gt;m 时，在 [1,i] 内选取随机数 d，如果 d&lt;=m，则使用第 i 个数据替换蓄水池中第 d 个数据，因此<strong>第 i 个数据进入过蓄水池的概率 = m/i</strong>。</li>
<li>当 i&lt;=m 时，程序从接收到第 m+1 个数据时开始执行替换操作，第 m+1 次处理会替换池中数据的为 m/(m+1)，会替换掉第 i 个数据的概率为 1/m，则第 m+1 次处理替换掉第 i 个数据的概率为 (m/(m+1))<em>(1/m)=1/(m+1)，不被替换的概率为 1-1/(m+1)=m/(m+1)。依次，第 m+2 次处理不替换掉第 i 个数据概率为 (m+1)/(m+2)… 第 N 次处理不替换掉第 i 个数据的概率为 (N-1)/N。所以，之后**第 i 个数据不被替换的概率 = m/(m+1)</em>(m+1)/(m+2)<em>…</em>(N-1)/N=m/N**。</li>
<li>当 i&gt;m 时，程序从接收到第 i+1 个数据时开始有可能替换第 i 个数据。则参考上述第 3 点，<strong>之后第 i 个数据不被替换的概率 = i/N</strong>。</li>
<li>结合第 1 点和第 3 点可知，当 i&lt;=m 时，第 i 个接收到的数据最后留在蓄水池中的概率 = 1<em>m/N=m/N。结合第 2 点和第 4 点可知，当 i&gt;m 时，第 i 个接收到的数据留在蓄水池中的概率 = m/i</em>i/N=m/N。综上可知，<strong>每个数据最后被选中留在蓄水池中的概率为 m/N</strong>。</li>
</ol>
<p>这个算法建立在统计学基础上，很巧妙地获得了 “m/N” 这个概率。</p>
<h2 id="三、深入一些——分布式蓄水池抽样（Distributed-Parallel-Reservoir-Sampling）"><a href="#三、深入一些——分布式蓄水池抽样（Distributed-Parallel-Reservoir-Sampling）" class="headerlink" title="三、深入一些——分布式蓄水池抽样（Distributed/Parallel Reservoir Sampling）"></a>三、深入一些——分布式蓄水池抽样（Distributed/Parallel Reservoir Sampling）</h2><p>一块 CPU 的计算能力再强，也总有内存和磁盘 IO 拖他的后腿。因此为提高数据吞吐量，分布式的硬件搭配软件是现在的主流。</p>
<p>如果遇到超大的数据量，即使是 O(N) 的时间复杂度，蓄水池抽样程序完成抽样任务也将耗时很久。因此分布式的蓄水池抽样算法应运而生。运作原理如下：</p>
<ol>
<li>假设有 K 台机器，将大数据集分成 K 个数据流，每台机器使用单机版蓄水池抽样处理一个数据流，抽样 m 个数据，并最后记录处理的数据量为 N1, N2, …, Nk, …, NK(假设 m&lt;Nk)。N1+N2+…+NK=N。</li>
<li>取 [1, N] 一个随机数 d，若 d&lt;N1，则在第一台机器的蓄水池中等概率不放回地（1/m）选取一个数据；若 N1&lt;=d&lt;(N1+N2)，则在第二台机器的蓄水池中等概率不放回地选取一个数据；一次类推，重复 m 次，则最终从 N 大数据集中选出 m 个数据。</li>
</ol>
<p>m/N 的概率验证如下：</p>
<ol>
<li>第 k 台机器中的蓄水池数据被选取的概率为 m/Nk。</li>
<li>从第 k 台机器的蓄水池中选取一个数据放进最终蓄水池的概率为 Nk/N。</li>
<li>第 k 台机器蓄水池的一个数据被选中的概率为 1/m。（不放回选取时等概率的）</li>
<li>重复 m 次选取，则每个数据被选中的概率为 <strong>m<em>(m/Nk</em>Nk/N*1/m)=m/N</strong>。</li>
</ol>
<h2 id="四、算法验证"><a href="#四、算法验证" class="headerlink" title="四、算法验证"></a>四、算法验证</h2><p>写一份完整的代码，用来验证蓄水池抽样的随机性。数据集大小为 1000，蓄水池容量为 10，做 10_0000 次抽样。如果程序正确，那么每个数被抽中的次数接近 1000 次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.njupt.qyz;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">public class ReservoirSampling &#123;</span><br><span class="line"></span><br><span class="line">    static ExecutorService exec = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">    // 抽样任务，用作模拟并行抽样</span><br><span class="line">    private static class SampleTask implements Callable&lt;int[]&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // 输入该任务的数据</span><br><span class="line">        private int[] innerData;</span><br><span class="line">        // 蓄水池容量</span><br><span class="line">        private int m;</span><br><span class="line"></span><br><span class="line">        SampleTask (int m, int[] innerData)</span><br><span class="line">        &#123;</span><br><span class="line">            this.innerData = innerData;</span><br><span class="line">            this.m = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int[] call() throws Exception</span><br><span class="line">        &#123;</span><br><span class="line">            int[] reservoir = sample(this.m, this.innerData);</span><br><span class="line">            return reservoir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 并行抽样</span><br><span class="line">    public static int[] mutiSample(int m, int[] dataStream) throws InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line"></span><br><span class="line">        int[] reservoir = initReservoir(m, dataStream);</span><br><span class="line"></span><br><span class="line">        // 生成3个范围内随机数，将数据切成4份</span><br><span class="line">        List&lt;Integer&gt; list = getRandInt(rand, dataStream.length); </span><br><span class="line">        int s1 = list.get(0);</span><br><span class="line">        int s2 = list.get(1);</span><br><span class="line">        int s3 = list.get(2);</span><br><span class="line">        // 每个任务处理的数据量</span><br><span class="line">        double n1 = s1 - 0;</span><br><span class="line">        double n2 = s2 - s1;</span><br><span class="line">        double n3 = s3 - s2;</span><br><span class="line">        double n4 = dataStream.length - s3;</span><br><span class="line"></span><br><span class="line">        // 并行抽样</span><br><span class="line">        Future&lt;int[]&gt; f1 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, 0, s1)));</span><br><span class="line">        Future&lt;int[]&gt; f2 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, s1, s2)));</span><br><span class="line">        Future&lt;int[]&gt; f3 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, s2, s3)));</span><br><span class="line">        Future&lt;int[]&gt; f4 = exec.submit(new SampleTask(m, Arrays.copyOfRange(dataStream, s3, dataStream.length)));</span><br><span class="line">        List&lt;Integer&gt; r1 = getList(f1.get());</span><br><span class="line">        List&lt;Integer&gt; r2 = getList(f2.get());</span><br><span class="line">        List&lt;Integer&gt; r3 = getList(f3.get());</span><br><span class="line">        List&lt;Integer&gt; r4 = getList(f4.get());</span><br><span class="line"></span><br><span class="line">        // 进行m次抽样</span><br><span class="line">        for (int i = 0; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int p = rand.nextInt(dataStream.length);</span><br><span class="line">            // 根据随机数落在的范围选择元素</span><br><span class="line">            if (p &lt; s1)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r1, rand.nextInt(r1.size()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p &lt; s2)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r2, rand.nextInt(r2.size()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p &lt; s3)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r3, rand.nextInt(r3.size()));</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[i] = getRandEle(r4, rand.nextInt(r4.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return reservoir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据输入返回随机位置的元素，并且删除该元素，模拟不放回</span><br><span class="line">    private static int getRandEle(List&lt;Integer&gt; list, int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        return list.remove(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取bound范围内的3个随机数，用来分割数据集</span><br><span class="line">    private static List&lt;Integer&gt; getRandInt(Random rand, int bound)</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        while (set.size() &lt; 3)</span><br><span class="line">        &#123;</span><br><span class="line">            set.add(rand.nextInt(bound));</span><br><span class="line">        &#125;</span><br><span class="line">        for (int e: set)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    // 数据转换成List</span><br><span class="line">    private static List&lt;Integer&gt; getList(int[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int a : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单机版蓄水池抽样</span><br><span class="line">    public static int[] sample(int m, int[] dataStream)</span><br><span class="line">    &#123;</span><br><span class="line">        // 随机数生成器，以系统当前nano时间作为种子</span><br><span class="line">        Random rand = new Random();</span><br><span class="line"></span><br><span class="line">        int[] reservoir = initReservoir(m, dataStream);</span><br><span class="line"></span><br><span class="line">        // init</span><br><span class="line">        for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            reservoir[i] = dataStream[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = m; i &lt; dataStream.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 随机获得一个[0, i]内的随机整数</span><br><span class="line">            int d = rand.nextInt(i + 1);</span><br><span class="line">            // 如果随机整数在[0, m-1]范围内，则替换蓄水池中的元素</span><br><span class="line">            if (d &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                reservoir[d] = dataStream[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reservoir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int[] initReservoir (int m, int[] dataStream)</span><br><span class="line">    &#123;</span><br><span class="line">        int[] reservoir;</span><br><span class="line"></span><br><span class="line">        if (m &gt; dataStream.length)</span><br><span class="line">        &#123;</span><br><span class="line">            reservoir = new int[dataStream.length];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            reservoir = new int[m];</span><br><span class="line">        &#125;</span><br><span class="line">        return reservoir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单机版测试</span><br><span class="line">    public void test()</span><br><span class="line">    &#123;</span><br><span class="line">        // 样本长度</span><br><span class="line">        int len = 1000;</span><br><span class="line">        // 蓄水池容量</span><br><span class="line">        int m = 10;</span><br><span class="line">        // 抽样次数，用作验证抽样的随机性</span><br><span class="line">        int iterTime = 100000;</span><br><span class="line">        // 每个数字被抽到的次数</span><br><span class="line">        int[] freq = new int[len];</span><br><span class="line">        // 样本</span><br><span class="line">        int[] dataStream = new int[len];</span><br><span class="line"></span><br><span class="line">        // init dataStream</span><br><span class="line">        for (int i = 0; i &lt; dataStream.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dataStream[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // count freq</span><br><span class="line">        for (int k = 0; k &lt; iterTime; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 进行抽样</span><br><span class="line">            int[] reservoir = sample(m, dataStream);</span><br><span class="line">            // 计算出现次数</span><br><span class="line">            for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int ele = reservoir[i];</span><br><span class="line">                freq[ele] += 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printStaticInfo(freq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试并行抽样</span><br><span class="line">    public void mutiTest() throws InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        // 样本长度</span><br><span class="line">        int len = 1000;</span><br><span class="line">        // 蓄水池容量</span><br><span class="line">        int m = 10;</span><br><span class="line">        // 抽样次数，用作验证抽样的随机性</span><br><span class="line">        int iterTime = 10_0000;</span><br><span class="line">        // 每个数字被抽到的次数</span><br><span class="line">        int[] freq = new int[len];</span><br><span class="line">        // 样本</span><br><span class="line">        int[] dataStream = new int[len];</span><br><span class="line"></span><br><span class="line">        // init dataStream</span><br><span class="line">        for (int i = 0; i &lt; dataStream.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dataStream[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // count freq</span><br><span class="line">        for (int k = 0; k &lt; iterTime; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 进行抽样</span><br><span class="line">            int[] reservoir = mutiSample(m, dataStream);</span><br><span class="line">            // 计算出现次数</span><br><span class="line">            for (int i = 0; i &lt; reservoir.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int ele = reservoir[i];</span><br><span class="line">                freq[ele] += 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printStaticInfo(freq);</span><br><span class="line">    &#125;</span><br><span class="line">    // 打印统计信息</span><br><span class="line">    private void printStaticInfo (int[] freq)</span><br><span class="line">    &#123;</span><br><span class="line">        // 期望、方差和标准差</span><br><span class="line">        double avg = 0;</span><br><span class="line">        double var = 0;</span><br><span class="line">        double sigma = 0;</span><br><span class="line">        // print</span><br><span class="line">        for (int i = 0; i &lt; freq.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i % 10 == 9) System.out.println();</span><br><span class="line">            System.out.print(freq[i] + &quot;, &quot;);</span><br><span class="line">            avg += ((double)(freq[i]) / freq.length);</span><br><span class="line">            var += (double)(freq[i] * freq[i]) / freq.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 输出统计信息</span><br><span class="line">        System.out.println(&quot;\n===============================&quot;);</span><br><span class="line">        var = var - avg * avg;</span><br><span class="line">        sigma = Math.sqrt(var);</span><br><span class="line">        System.out.println(&quot;Average: &quot; + avg);</span><br><span class="line">        System.out.println(&quot;Variance: &quot; + var);</span><br><span class="line">        System.out.println(&quot;Standard deviation: &quot; + sigma);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) throws InterruptedException, ExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        ReservoirSampling rs = new ReservoirSampling();</span><br><span class="line">        rs.mutiTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单机版输出和并行版的输出类似，截取片段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">948, 1006, 1014, 1019, 1033, 1040, 948, 1014, 1000, 951, </span><br><span class="line">1014, 987, 1049, 1043, 1034, 983, 1006, 974, 1060, 1009, </span><br><span class="line">986, 1021, 1024, 963, 1041, 1028, 988, 1011, 975, 980, </span><br><span class="line">1055, 1017, 1010, 1018, 1013, 983, 942, 1056, 1003, 1063, </span><br><span class="line">1004, 1004, 999, 976, 957, 935, 1061, 1018, 1002, 1018, </span><br><span class="line">1019, 946, 985, 1057, 1012, 965, 978, 1040, 1026, 1064, </span><br><span class="line">1026, 1018, 980, 996, 1025, 1028, 1006, 944, 986, 981, </span><br><span class="line">923, 1015, 991, 1019, 1024, 1143, 989, 985, 1022, 1019, </span><br><span class="line">1004, 1000, 989, 972, 1041, 988, 1050, 932, 975, 1037, </span><br><span class="line">1016, 983, 1051, 1003, 983, 986, 1017, 1009, 936, 993, </span><br><span class="line">965, 976, 1001, 1000, 988, 1030, 1050, 1024, 981, 985, </span><br><span class="line">935, 1023, 996, 1007, 1013, 1046, 1003, 1006, 973, 989, </span><br><span class="line">943, </span><br><span class="line">===============================</span><br><span class="line">Average: 1000.0000000000002</span><br><span class="line">Variance: 1011.8799999983748</span><br><span class="line">Standard deviation: 31.81006130139291</span><br></pre></td></tr></table></figure>
<p>此外，为了对比单机版与并行版（4 线程）的性能差异，使用 10_0000 大小的数据集，蓄水池容量 10，进行 100_0000 次重复抽样，对比两者的运行时间。结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---------单机版----------</span><br><span class="line"></span><br><span class="line">===============================</span><br><span class="line">Average: 100.00000000000125</span><br><span class="line">Variance: 100.31497999751264</span><br><span class="line">Standard deviation: 10.015736617818613</span><br><span class="line">---------并行版----------</span><br><span class="line"></span><br><span class="line">===============================</span><br><span class="line">Average: 100.00000000000169</span><br><span class="line">Variance: 100.63045999737915</span><br><span class="line">Standard deviation: 10.031473470900432</span><br><span class="line">单机版耗时：2006s</span><br><span class="line">并行版耗时：1265s</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，算法保证了数据选取的随机性。且并行版算法能够有效提高数据吞吐量。</p>
<h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><p>蓄水池抽样的 O(N) 时间复杂度，O(m) 空间复杂度令其适用于对流数据、大数据集的等概率抽样。比如一个大文本数据，随机输出其中的几行。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>象征性总结：优雅巧妙的算法——蓄水池抽样。</p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><ol>
<li><a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.jobbole.com%2F42550%2F" target="_blank" rel="noopener">数据工程师必知算法：蓄水池抽样</a></li>
<li><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fpython27%2Fp%2FReservoir_Sampling_Algorithm.html" target="_blank" rel="noopener">【算法 34】蓄水池抽样算法 (Reservoir Sampling Algorithm)</a></li>
<li><a href="https://www.jianshu.com/p/eea05fb27e3f" target="_blank" rel="noopener">分布式 / 并行蓄水池抽样 (Distributed/Parallel Reservoir Sampling)</a></li>
<li><a href="https://link.jianshu.com?t=https%3A%2F%2Fballsandbins.wordpress.com%2F2014%2F04%2F13%2Fdistributedparallel-reservoir-sampling%2F" target="_blank" rel="noopener">Distributed/Parallel Reservoir Sampling</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/29/蓄水池抽样算法/" data-id="cjrnyarcm000c9lkmgz8ctpor" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试 - AQS- CAS" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/25/面试 - AQS- CAS/" class="article-date">
  <time datetime="2019-01-25T16:01:51.477Z" itemprop="datePublished">2019-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转 <a href="http://www.cnblogs.com/xiexj/p/6845029.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiexj/p/6845029.html</a></p>
<p>看了左潇龙的《<a href="http://www.cnblogs.com/zuoxiaolong/p/life51.html" target="_blank" rel="noopener">回答阿里社招面试如何准备，顺便谈谈对于 Java 程序猿学习当中各个阶段的建议</a>》这篇文章，在想一个问题，从一个最简单的问题入手究竟能把问题问多深？下面就模拟一场面试问答，要是我是面试官，大概就只能问到下面的深度了。</p>
<p>旁白：一般的面试都是从最简单基本的问题开始。</p>
<p>面试官：请在黑板上写出一个线程安全的单例模式的例子。</p>
<p>面试者：</p>
<p>　　其实线程安全的实现有很多种，根据业务场景可以 new 一个实例作为私有静态成员变量，这样程序一启动，实例就生成，私有化构造函数，利用公用的静态函数 getInstance 返回实例。这种预加载的是能保证线程安全的但是如果不是确定会被使用，会造成内存的浪费，所以可以将实例放到私有静态类中作为成员变量。下面只写一种利用锁机制来保证的懒加载方法。</p>
<pre>public class Singleton { 
    private volatile static Singleton singleton; 
    private Singleton (){} 
    public static Singleton getSingleton() { 
    if (singleton == null) { 
        synchronized (Singleton.class) { 
        if (singleton == null) { 
            singleton = new Singleton(); 
        } 
        } 
    } 
    return singleton; 
    } 
}</pre>

<p>或者</p>
<pre>public class Singleton{    
    private static Singletoninstance = new Singleton();
    private Singleton(){}

    public static Singleton getInstance() {
        return instance;
    }
}</pre>

<p>旁白：从这个例子上我能想到的知识点主要有三个</p>
<p>　　   ☆　volatile 关键字，可深入到 Java VM 内存相关</p>
<p>　　   ☆　synchronized 关键字，可深入到 Java 锁机制，高并发相关</p>
<p>　　   ☆　new 关键字，可深入到 Java VM 类加载机制相关</p>
<p>但是面试官一开始可能要先考察一下面试者是否真的理解自己写的代码</p>
<p>面试官：你写的这个程序是怎么保证线程安全的？</p>
<p>面试者：将类的构造方法私有起来，外部调用进行初始化的时候只能通过调用 getSingleton 这个静态方法来获得实例，静态方法是整个 Java 虚拟机中只有一个实例。在创建的时候首先进行非空判断，这时候如果实例不存在，对整个类进行加锁同步，为了避免过程中非空状态的改变，同步块内再进行一次判断，如果不存在实例则创建实例返回。使用 volatile 关键字，下次访问这个方法就能直接看到实例的最新非空状态，直接返回实例。</p>
<p>面试官：volatile 起到了什么作用？</p>
<p>面试者：volatile 这个英文单词意思是易变的，用在多线程中来同步变量。Java 的对象都是在内存堆中分配空间。但是 Java 有主内存和线程自己独有的内存拷贝。对于没有 volatile 修饰的局部变量，线程在运行过程中访问的是工作内存中的变量值，其修改对于主内存不是立即可见。而 volatile 修饰的值在线程独有的工作内存中无副本，线程直接和主内存交互，修改对主内存立即可见。</p>
<p>面试官：synchronized 起到了什么作用？</p>
<p>面试者：锁定对象，限制当前对象只能被一个线程访问。</p>
<p>面试官：synchronized 里你传 Singleton.class 这个参数，起到什么作用，换成别的行不行？</p>
<p>面试者：对当前类加锁，使得这个代码块一次只能被一个线程访问。这里 Singleton.class 可以换成一个常量字符串或者自己定义一个内部静态 Object。</p>
<p>面试官：那传 Singleton.class，常量字符串，自己定义一个内部静态 Object 有区别吗？</p>
<p>面试者：因为这是一个静态方法，相当于一个概念上的类锁，所以在这里起到的效果是一样的。但是如果是原型模式，或者直接每个类都是 new 出来的，实例不同的话，在一个非静态方法里加这三种锁，这时是一个对象锁，因为 Singleton.class 或者是静态的一个 Object 或者是 JVM 只存一份的字符串常量，这些对象线程间是共享的，会对所有的实例的同步块都加同一把锁，每个实例访问到此对象的同步代码块都会被阻塞。但是如果这时 synchronized 的参数是 this，或者是内部 new 出来的一个内部非静态 Object，则各个实例拥有不同的锁，访问同一个代码相同同步块也是互不干扰。只有实例内部使用了同一个对象锁才会同步等待。</p>
<p>面试官：那你知道 synchronized 关键字实现同步的原理吗？</p>
<p>面试者：synchronized 在 Java 虚拟机中使用监视器锁来实现。每个对象都有一个监视器锁，当监视器锁被占用时就会处于锁定状态。</p>
<p>　　线程执行一条叫 monitorenter 的指令来获取监视器锁的所有权。如果此监视器锁的进入数为 0，则线程进入并将进入数设置为 1，成为线程所有者。如果线程已经拥有该锁，因为是可重入锁，可以重新进入，则进入数加 1. 如果线程的监视器锁被其他线程占用，则阻塞直到此监视器锁的进入数为 0 时才能进入该锁。</p>
<p>　　线程执行一条叫 monitorexit 的指令来释放所有权。执行 monitorexit 的必须是线程的所有者。每次执行此指令，线程进入数减 1，直到进入数为 0。监视器锁被释放。</p>
<p>面试官：你刚才提到的可重入锁是什么概念，有不可重入锁吗？</p>
<p>面试者：我说的可重入锁是广义的可重入锁，当然 jdk1.5 引入了 concurrent 包，里面有 Lock 接口，它有一个实现叫 ReentrantLock。广义的可重入锁也叫递归锁，是指同一线程外层函数获得锁之后，内层还可以再次获得此锁。可重入锁的设计是为了避免死锁。sun 的 corba 里的 mutex 互斥锁是一种不可重入锁的实现。自旋锁也是一种不可重入锁，本质上是一种忙等锁，CPU 一直循环执行 “测试并设置” 直到可用并取得该锁，在递归的调用该锁时必然会引起死锁。另外，如果锁占用时间较长，自旋锁会过多的占用 CPU 资源，这时使用基于睡眠原理来实现的锁更加合适。</p>
<p>面试官：你刚才提到了 concurrent 包，它里面有哪些锁的实现？</p>
<p>面试者：常用的有 ReentrantLock, 它是一种独占锁。ReadWriteLock 接口也是一个锁接口，和 Lock 接口是一种关联关系，它返回一个只读的 Lock 和只写的 Lock。读写分离，在没有写锁的情况下，读锁是无阻塞的，提高了执行效率，它是一种共享锁。ReadWriteLock 的实现类为 ReentrantReadWriteLock。ReentrantLock 和 ReentrantReadWriteLock 实现都依赖于 AbstractQueuedSynchronizer 这种抽象队列同步器。</p>
<p>面试官：锁还有其他维度的分类吗？</p>
<p>面试者：还可以分为公平锁和非公平锁。非公平锁是如果一个线程尝试获取锁时可以获取锁，就直接成功获取。公平锁则在锁被释放后将锁分配给等待队列队首的线程。</p>
<p>面试官：AQS 是什么？</p>
<p>面试者：AQS 是一个简单的框架，这个框架为同步状态的原子性管理，线程的阻塞和非阻塞以及排队提供了一种通用机制。表现为一个同步器，主要支持获取锁和释放锁。获取锁的时候如果是独占锁就有可能阻塞，如果是共享锁就有可能失败。如果是阻塞，线程就要进入阻塞队列，当状态变成可获得锁就修改状态，已进入阻塞队列的要从阻塞队列中移除。释放锁时修改状态位及唤醒其他被阻塞的线程。</p>
<p>AQS 本质是采用 CHL 模型完成了一个先进先出的队列。对于入队，采用 CAS 操作，每次比较尾节点是否一致，然后插入到尾节点中。对于出队列，因为每个节点缓存了一个状态位，不满足条件时自旋等待，直到满足条件时将头节点设置为下一个节点。</p>
<p>面试官：那知道这个队列的数据结构吗？</p>
<p>面试者：这个队列是用一个双向链表实现的。</p>
<p>面试官：你刚才提到 AQS 是一种通用机制，那它还有哪些应用?</p>
<p>面试者：AQS 除了刚才提到的可重入锁 ReentrantLock 和 ReentrantReadWriteLock 之外，还用于不可重入锁 Mutex 的实现。java 并发包中的同步器如：Semphore,CountDownLatch,FutureTask,CyclicBarrier 都是采用这个机制实现的。</p>
<p>旁白：既然问到了并发工具包中的东西，每个都可以引出一堆，但是基本原理已经问出来了，其他的问下去没什么意思。转向下一个问题。</p>
<p>面试官：你黑板上写的实例是通过 new 对象创建出来的，还可不可以采用别的方法来创建对象呢？</p>
<p>面试者：还可以使用 class 类的 newInstance 方法，Constructor 构造器类的 newInstance 方法，克隆方法和反序列法方法。</p>
<p>面试官：两种 newInstance 方法有没有区别？</p>
<p>面试者：</p>
<p>　　☆　Class 类位于 java 的 lang 包中，而构造器类是 java 反射机制的一部分。</p>
<p>　　☆　Class 类的 newInstance 只能触发无参数的构造方法创建对象，而构造器类的 newInstance 能触发有参数或者任意参数的构造方法来创建对象。</p>
<p>　　☆　Class 类的 newInstance 需要其构造方法是共有的或者对调用方法可见的，而构造器类的 newInstance 可以在特定环境下调用私有构造方法来创建对象。</p>
<p>　　☆　Class 类的 newInstance 抛出类构造函数的异常，而构造器类的 newInstance 包装了一个 InvocationTargetException 异常。</p>
<p>　　Class 类本质上调用了反射包构造器类中无参数的 newInstance 方法，捕获了 InvocationTargetException，将构造器本身的异常抛出。</p>
<p>面试官：类加载的时候，自己定义了一个类和 java 自己的类类名和命名空间都一样，JVM 加载的是哪一个呢？</p>
<p>面试者：调用的是 java 自身的，根据双亲委派模型，最委派 Bootstrap 的 ClassLoader 来加载，找不到才去使用 Extension 的 ClassLoader，还找不到才去用 Application 的 ClassLoader，这种机制利于保证 JVM 的安全。</p>
<p>面试官：你刚才提到的 java 的反射机制是什么概念？</p>
<p>面试者：java 的反射机制是在运行状态中，对于任何一个类，都能够知道它所有的属性和方法；对于任何一个对象，都能够调用它的任何一个方法和属性。这种动态的获取信息和动态调用对象的方法的功能就是 java 的反射机制。它是 jdk 动态代理的实现方法。</p>
<p>面试官：java 还有没有其他的动态代理实现？</p>
<p>面试者：还有 cglib 动态代理。</p>
<p>面试官：这两种动态代理哪个比较好呢？</p>
<p>面试者：AOP 源码中同时使用了这两种动态代理，因为他们各有优劣。jdk 动态代理是利用 java 内部的反射机制来实现，在生成类的过程中比较高效，cglib 动态代理则是借助 asm 来实现，可以利用 asm 将生成的类进行缓存，所以在类生成之后的相关执行过程中比较高效。但是 jdk 的动态代理前提是目标类必须基于统一的接口，所以有一定的局限性。</p>
<p>旁白：面试者都已经提到 AOP 了，那么接下来横向，纵向，怎样都能问出一大堆问题，就不赘述。基于上面问题，读者也可以自己画出一棵知识树，然后就能找到能对答如流的终极方案：就是基本都没超过《深入理解 java 虚拟器》《java 并发编程实践》这两本书，大学学过的《数据结构与算法》《编译原理》掌握的好也可以在面试中加分哦。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/25/面试 - AQS- CAS/" data-id="cjrnyarcn000d9lkmdfxy5k1u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的使用和理解线程池" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/25/如何优雅的使用和理解线程池/" class="article-date">
  <time datetime="2019-01-25T14:24:57.807Z" itemprop="datePublished">2019-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808901?w=766&amp;h=136" alt=""></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<ul>
<li>线程是稀缺资源，不能频繁的创建。</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>应当将其放入一个池子中，可以给其他任务进行复用。</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
<li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
<li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>
<p>其实看这三种方式创建的源码就会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>
<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(new Job());</span><br></pre></td></tr></table></figure>
<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808902?w=707&amp;h=126" alt=""></p>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p>用图表示为：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808903?w=1033&amp;h=406" alt=""></p>
<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808904?w=754&amp;h=310" alt=""></p>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
<p>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808905?w=500&amp;h=293" alt=""></p>
<h3 id="如何配置线程"><a href="#如何配置线程" class="headerlink" title="如何配置线程"></a>如何配置线程</h3><p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2</li>
<li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>
<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<blockquote>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt;= 5; i++) &#123;</span><br><span class="line">    pool.execute(new Job());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line">while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(&quot;线程还在执行。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start));</span><br></pre></td></tr></table></figure>
<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><blockquote>
<p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>
<p>如果我们很多业务都依赖于同一个线程池, 当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>
<p>通常的做法是按照业务进行划分：</p>
<blockquote>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h3><p>这样的需求 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a> 已经帮我们实现了。</p>
<blockquote>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>
<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Function:订单服务</span><br><span class="line"> *</span><br><span class="line"> * @author crossoverJie</span><br><span class="line"> *         Date: 2018/7/28 16:43</span><br><span class="line"> * @since JDK 1.8</span><br><span class="line"> */</span><br><span class="line">public class CommandOrder extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);</span><br><span class="line"></span><br><span class="line">    private String orderName;</span><br><span class="line"></span><br><span class="line">    public CommandOrder(String orderName) &#123;</span><br><span class="line"></span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                //服务分组</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;))</span><br><span class="line">                //线程分组</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;))</span><br><span class="line"></span><br><span class="line">                //线程池配置</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(10)</span><br><span class="line">                        .withKeepAliveTimeMinutes(5)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(10000))</span><br><span class="line"></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;orderName=[&#123;&#125;]&quot;, orderName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        return &quot;OrderName=&quot; + orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Function:用户服务</span><br><span class="line"> *</span><br><span class="line"> * @author crossoverJie</span><br><span class="line"> *         Date: 2018/7/28 16:43</span><br><span class="line"> * @since JDK 1.8</span><br><span class="line"> */</span><br><span class="line">public class CommandUser extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public CommandUser(String userName) &#123;</span><br><span class="line"></span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                //服务分组</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;))</span><br><span class="line">                //线程分组</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;))</span><br><span class="line"></span><br><span class="line">                //线程池配置</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(10)</span><br><span class="line">                        .withKeepAliveTimeMinutes(5)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(10000))</span><br><span class="line"></span><br><span class="line">                //线程池隔离</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;userName=[&#123;&#125;]&quot;, userName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        return &quot;userName=&quot; + userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    CommandOrder commandPhone = new CommandOrder(&quot;手机&quot;);</span><br><span class="line">    CommandOrder command = new CommandOrder(&quot;电视&quot;);</span><br><span class="line"></span><br><span class="line">    //阻塞方式执行</span><br><span class="line">    String execute = commandPhone.execute();</span><br><span class="line">    LOGGER.info(&quot;execute=[&#123;&#125;]&quot;, execute);</span><br><span class="line"></span><br><span class="line">    //异步非阻塞方式</span><br><span class="line">    Future&lt;String&gt; queue = command.queue();</span><br><span class="line">    String value = queue.get(200, TimeUnit.MILLISECONDS);</span><br><span class="line">    LOGGER.info(&quot;value=[&#123;&#125;]&quot;, value);</span><br><span class="line"></span><br><span class="line">    CommandUser commandUser = new CommandUser(&quot;张三&quot;);</span><br><span class="line">    String name = commandUser.execute();</span><br><span class="line">    LOGGER.info(&quot;name=[&#123;&#125;]&quot;, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808909?w=928&amp;h=160" alt=""></p>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<blockquote>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>
<p>通过刚才的构造函数也能证明：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015808910?w=1104&amp;h=334" alt=""></p>
<p>还要注意的一点是：</p>
<blockquote>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 <code>This instance can only be executed once. Please instantiate a new instance.</code> 异常。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>
<p>文末的 hystrix 源码：<br><a href="https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix" target="_blank" rel="noopener">https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/25/如何优雅的使用和理解线程池/" data-id="cjrnyarcg00099lkmhqvdjtka" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线上服务 CPU100% 问题快速定位实战" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/25/线上服务 CPU100% 问题快速定位实战/" class="article-date">
  <time datetime="2019-01-25T12:52:47.320Z" itemprop="datePublished">2019-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>功能问题，通过日志，单步调试相对比较好定位。</p>
<p>性能问题，例如线上<a href="https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">服务器</a> CPU100%，如何找到相关服务，如何定位问题代码，更考验技术人的功底。</p>
<p>58 到家架构部，运维部，58 速运<a href="https://www.baidu.com/s?wd=%E6%8A%80%E6%9C%AF%E9%83%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">技术部</a>联合进行了一次线上服务 CPU 问题排查实战演练，同学们反馈有收获，特将实战演练的试题和答案公布出来，希望对大家也有帮助。</p>
<p>题目</p>
<p>某服务器上部署了若干 tomcat 实例，即若干垂直切分的 Java 站点服务，以及若干 Java 微服务，突然收到运维的 CPU 异常告警。</p>
<p>问：如何定位是哪个服务进程导致 CPU 过载，哪个线程导致 CPU 过载，哪段代码导致 CPU 过载？</p>
<p>步骤一、找到最耗 CPU 的进程</p>
<p>工具：top</p>
<p>方法：</p>
<ul>
<li><p>执行 top -c ，显示进程运行信息列表</p>
</li>
<li><p>键入 P (大写 p)，进程按照 CPU 使用率排序</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155433936?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，最耗 CPU 的进程 PID 为 10765</p>
<p>步骤二：找到最耗 CPU 的线程</p>
<p>工具：top</p>
<p>方法：</p>
<ul>
<li><p>top -Hp 10765 ，显示一个进程的线程运行信息列表</p>
</li>
<li><p>键入 P (大写 p)，线程按照 CPU 使用率排序</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155519686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，进程 10765 内，最耗 CPU 的线程 PID 为 10804</p>
<p>步骤三：将线程 PID 转化为 16 进制</p>
<p>工具：printf</p>
<p>方法：printf “%x\n” 10804</p>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155607290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，10804 对应的 16 进制是 0x2a34，当然，这一步可以用计算器。</p>
<p>之所以要转化为 16 进制，是因为堆栈里，线程 id 是用 16 进制表示的。</p>
<p>步骤四：查看堆栈，找到线程在干嘛</p>
<p>工具：pstack/jstack/grep</p>
<p>方法：jstack 10765 | grep ‘0x2a34’ -C5 –color</p>
<ul>
<li><p>打印进程堆栈</p>
</li>
<li><p>通过线程 id，过滤得到线程堆栈</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://img-blog.csdn.net/20170820155648798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd6aGV4aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图，找到了耗 CPU 高的线程对应的线程名称 “AsyncLogger-1”，以及看到了该线程正在执行代码的堆栈。</p>
<p>希望对经常进行线上 CPU 问题排查的同学有帮助，如果有更好的实践，也欢迎分享。</p>
<p>想要印象深刻，请大家务必线上实操练习哟。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/25/线上服务 CPU100% 问题快速定位实战/" data-id="cjrnyarcb00089lkm4t2m17ci" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-理解 B 树、B+ 树特点及使用场景" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/22/理解 B 树、B+ 树特点及使用场景/" class="article-date">
  <time datetime="2019-01-22T21:23:45.330Z" itemprop="datePublished">2019-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读完本文你将了解：</p>
<ul>
<li><a href="#b-树">B 树</a><ul>
<li><a href="#对比平衡二叉树和-b-树">对比平衡二叉树和 B 树</a></li>
<li><a href="#b-树中如何查找数据">B 树中如何查找数据</a></li>
<li><a href="#b-树如何保证平衡">B 树如何保证平衡</a></li>
<li><a href="#使用场景">使用场景</a></li>
</ul>
</li>
<li><a href="#b-树-1">B+ 树</a></li>
<li><a href="#thanks">Thanks</a></li>
</ul>
<p>大家好，前面那篇文章<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FK_oGI2rl3epTirxkST5LVQ" target="_blank" rel="noopener">《3 分钟理解完全二叉树、平衡二叉树、二叉查找树》</a>中我们了解了几种特殊的二叉树的功能及特点，知道了它们在进行查找数据时可以提高效率，但需要注意的是，这是指在内存中进行查找。如果有海量的数据，不可能一次性读取到内存中，这时候就要考虑的是，如何在磁盘中快速找到需要的数据。</p>
<p>今天这篇文章中要介绍的 “B 树、B+ 树”，他们的使用场景是：查找磁盘中的大量数据。</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h1><p>B 树就是常说的 “B 减树（B- 树）”，又名平衡多路（即不止两个子树）查找树，它和平衡二叉树的不同有这么几点：</p>
<ol>
<li>平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，<strong>M 阶 B 树表示该树每个节点最多有 M 个子树</strong></li>
<li>平衡二叉树每个节点只有一个数据和两个指向孩子的指针，而 B 树每个<strong>中间节点</strong>有 k-1 个关键字（可以理解为数据）和 k 个子树（ **k 介于阶数 M 和 M/2 之间，M/2 向上取整）</li>
<li>B 树的所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null</li>
</ol>
<p>和平衡二叉树相同的点在于：B 树的节点数据大小也是按照左小右大，子树与节点的大小比较决定了子树指针所处位置。</p>
<p>看着概念可能有点难理解，来看看图对比下平衡二叉树和 B 树。</p>
<h2 id="对比平衡二叉树和-B-树"><a href="#对比平衡二叉树和-B-树" class="headerlink" title="对比平衡二叉树和 B 树"></a>对比平衡二叉树和 B 树</h2><p>首先是节点， 平衡二叉树的节点如下图所示，每个节点有一个数据和最多两个子树：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a83c2850cba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>B 树中的每个节点由两部分组成：</p>
<ol>
<li>关键字（可以理解为数据）</li>
<li>指向孩子节点的指针</li>
</ol>
<p>B 树的节点如下图所示，每个节点可以有不只一个数据，同时拥有<strong>数据数加一</strong>个子树，同时每个节点左子树的数据比当前节点都小、右子树的数据都比当前节点的数据大：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a83c2c6d53b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<blockquote>
<p>上图是为了方便读者理解 B 树每个节点的内容，实际绘制图形还是以圆表示每个节点。</p>
</blockquote>
<p>了解了节点的差异后，来看看 B 树的定义，<strong>一棵 B 树必须满足以下条件</strong>：</p>
<ol>
<li>若根结点不是终端结点，则至少有 2 棵子树</li>
<li>除根节点以外的所有非叶结点至少有 M/2 棵子树，至多有 M 个子树（关键字数为子树减一）</li>
<li>所有的叶子结点都位于同一层</li>
</ol>
<p>用一张图对比平衡二叉树和 B 树：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a83c2bc8726?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>可以看到，<strong>B 树的每个节点可以表示的信息更多，因此整个树更加 “矮胖”，这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度。</strong></p>
<h2 id="B-树中如何查找数据"><a href="#B-树中如何查找数据" class="headerlink" title="B 树中如何查找数据"></a>B 树中如何查找数据</h2><p>因为 B 树的子树大小排序规则，因此在 B 树中查找数据时，一般需要这样：</p>
<ol>
<li>从根节点开始，如果查找的数据比根节点小，就去左子树找，否则去右子树</li>
<li>和子树的多个关键字进行比较，找到它所处的范围，然后去范围对应的子树中继续查找</li>
<li>以此循环，直到找到或者到叶子节点还没找到为止</li>
</ol>
<h2 id="B-树如何保证平衡"><a href="#B-树如何保证平衡" class="headerlink" title="B 树如何保证平衡"></a>B 树如何保证平衡</h2><p>我们知道，平衡的树之所以能够加快查找速度，是因为在添加、删除的时候做了某些操作以保证平衡。</p>
<p>平衡二叉树的平衡条件是：<strong>左右子树的高度差不大于 1</strong>；而 B 树的平衡条件则有三点：</p>
<ol>
<li>叶子节点都在同一层</li>
<li>每个节点的关键字数为子树个数减一（子树个数 k 介于树的阶 M 和它的二分之一</li>
<li>子树的关键字保证左小右大的顺序</li>
</ol>
<p>也就是说，一棵 3 阶的 B 树（即节点最多有三个子树），每个节点的关键字数最少为 1，最多为 2，如果要添加数据的子树的关键字数已经是最多，就需要<strong>拆分节点，调整树的结构。</strong></p>
<p>网上找到一张很不错的动图，我们来根据它分析下 B 树添加元素时如何保证平衡。</p>
<p>这个图用以表示往 4 阶 B 树中依次插入下面这组数据的过程：</p>
<p>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a83c2de95ba?imageslim" alt=""></p>
<p><strong>建议放大图查看</strong>。</p>
<p>由于我比较懒，我们来根据前几步分析下 B 树的添加流程：</p>
<ol>
<li>首先明确：<strong>4 阶 B 树表示每个节点最多有 4 个子树、3 个关键字，最少有 2 个子树、一个关键字</strong></li>
<li>添加 6，第一个节点，没什么好说的</li>
<li>添加 10，根节点最多能放三个关键字，按顺序添到根节点中</li>
<li>添加 4，还能放到根节点中</li>
<li>添加 14，这时超出了关键字最大限制，需要把 14 添加为子树，同时为了保证 “所有叶子节点在同一层”，就需要拆几个关键字作为子树：</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a8432fdb64b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""> 拆为：<img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a8433e01546?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>这个拆的过程比较复杂，首先要确定根节点保留几个关键字，由于 <strong>“非叶子节点的根节点至少有 2 棵子树”</strong> 的限制，那就至少需要两个关键字分出去，又因为 <strong>“子树数是关键字数 + 1”</strong>，如果根节点有两个关键字，就得有三个子树，无法满足，所以只好把除 6 以外的三个关键字都拆为子树。</p>
<p>谁和谁在一个子树上呢，根据 <strong>“左子树比关键字小、右子树比关键字大”</strong> 的规律，4 在左子树，10 和 14 在右子树。</p>
<p>继续添加 ：</p>
<ol>
<li>添加 5，放到 4 所在的子树上</li>
<li>添加 11，放在 10 和 14 所在的右子树上</li>
<li>添加 15，按大小应该放到 10、11 和 14 所在的子树上，但因为超过了关键字数限制，又得拆分</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a843f1656c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>因为 <strong>“根节点必须都在同一层”</strong>，因此我们不能给现有的左右子树添加子树，只能添加给 6 了；但是如果 6 有三个子树，就必须得有 2 个关键字，提升谁做关键字好呢，这得看谁做 6 中间的子树，因为右子树的所有关键字都得比父节点的关键字大，所以这个提升的关键字只能比未来右子树中的关键字都小，那就只有 10 和 11 可以考虑了。</p>
<p>提升 10 吧，没有比它小的做子树，那就只能提升 11 了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a8449e5305e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>再添加元素也是类似的逻辑：</p>
<ol>
<li>首先考虑要插入的子树是否已经超出了关键字数的限制</li>
<li>超出的话，如果要插入的位置是叶子节点，就只能拆一个关键字添加到要插入位置的父节点</li>
<li>如果非叶子节点，就得从其他子树拆子树给新插入的元素做孩子</li>
</ol>
<p>删除也是一样的，要考虑删除孩子后，父节点是否还满足子树 k 介于 M/2 和 M 的条件，不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡。</p>
<p>总之添加、删除的过程很复杂，要考虑的条件很多，具体实现就不细追究了，这里我们有个基本认识即可。</p>
<p>正是这个复杂的保持平衡操作，使得平衡后的 B 树能够发挥出磁盘中快速查找的作用。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><blockquote>
<p>这部分摘自：<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.jobbole.com%2F79311%2F" target="_blank" rel="noopener">浅谈算法和数据结构：平衡查找树之 B 树</a></p>
</blockquote>
<p>文件系统和数据库系统中常用的 B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少 IO 操作。他广泛用于文件系统及数据库中，如：</p>
<ul>
<li><p>Windows：HPFS 文件系统</p>
</li>
<li><p>Mac：HFS，HFS+ 文件系统</p>
</li>
<li><p>Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统</p>
</li>
<li><p>数据库：ORACLE，MYSQL，SQLSERVER 等中</p>
</li>
<li><p>数据库：ORACLE，MYSQL，SQLSERVER 等中</p>
</li>
</ul>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h1><blockquote>
<p>这部分主要学习自 “程序员小灰” 的 <a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FjRZMMONW3QP43dsDKIV9VQ" target="_blank" rel="noopener">漫画：什么是 B + 树？</a></p>
</blockquote>
<p>了解了 B 树后再来了解下它的变形版：B+ 树，它比 B 树的查询性能更高。</p>
<p>一棵 B+ 树需要满足以下条件：</p>
<ol>
<li>节点的子树数和关键字数相同（B 树是关键字数比子树数少一）</li>
<li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li>
<li>叶子节点包含了全部数据，同时符合左小右大的顺序</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a844c9a40b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>简单概括下 B+ 树的三个特点：</p>
<ol>
<li>关键字数和子树相同</li>
<li>非叶子节点仅用作索引，它的关键字和子节点有重复元素</li>
<li>叶子节点用指针连在一起</li>
</ol>
<p>首先第一点不用特别介绍了，在 B 树中，节点的关键字用于在查询时确定查询区间，因此关键字数比子树数少一；而在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</p>
<p>第二点，除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</p>
<blockquote>
<p>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</p>
</blockquote>
<p>第三点，叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</p>
<p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加 “矮胖”，因此查询效率更快。</p>
<p>B+ 树的查找必会查到叶子节点，更加稳定。</p>
<p>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p>
<p>B+ 树的三个优点：</p>
<ol>
<li>层级更低，IO 次数更少</li>
<li>每次都需要查询到叶子节点，查询性能稳定</li>
<li>叶子节点形成有序链表，范围查询方便</li>
</ol>
<p>添加过程就不深入研究了，后面用到再看吧，这里先贴一个 B+ 树动态添加元素图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9a844ffb91f5?imageslim" alt=""></p>
<h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F30527705" target="_blank" rel="noopener">www.zhihu.com/question/30…</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27700617" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/27700617</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FjRZMMONW3QP43dsDKIV9VQ" target="_blank" rel="noopener">mp.weixin.qq.com/s/jRZMMONW3…</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fblog.jobbole.com%2F79311%2F" target="_blank" rel="noopener">blog.jobbole.com/79311/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/22/理解 B 树、B+ 树特点及使用场景/" data-id="cjrnyarch000a9lkmrx7rukph" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/02/TCP为什么是三次握手/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/02/mysql explain 详解/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/02/为什么你需要一个 vps/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/31/spring boot 扫描不到自定义 Controller/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/31/SpringCloud 警告 (Eureka)：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE./">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 woo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>