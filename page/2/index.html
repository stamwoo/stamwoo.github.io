<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Blog of Woo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Blog of Woo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Blog of Woo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog of Woo">
  
    <link rel="alternate" href="/atom.xml" title="Blog of Woo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog of Woo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-极光之旅" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/21/极光之旅/" class="article-date">
  <time datetime="2019-01-21T20:43:52.166Z" itemprop="datePublished">2019-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="极光之旅"><a href="#极光之旅" class="headerlink" title="极光之旅"></a>极光之旅</h2><p>1.23号早上7点极光进入高峰期,因此22号晚上到.</p>
<p>23,24,25三天高峰.</p>
<p>22晚到挪威,25号上午从挪威回来.</p>
<p>住22一晚,23一晚,24一晚</p>
<p>住airbnb,汽车极光团.</p>
<ol>
<li>极光kp指数 &gt; 3</li>
<li>天气未来三天为晴朗</li>
<li>不在农历10-20号范围内</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/21/极光之旅/" data-id="cjrnxzmfs0006z7km85j3jgzi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-为什么匿名内部类访问局部变量必须是 final" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/21/为什么匿名内部类访问局部变量必须是 final/" class="article-date">
  <time datetime="2019-01-21T18:40:41.660Z" itemprop="datePublished">2019-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="http://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/" target="_blank" rel="noopener">http://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/</a></p>
</blockquote>
<h2 id="一个谜团"><a href="#一个谜团" class="headerlink" title="一个谜团"></a>一个谜团</h2><p>如果你用过类似 guava 这种 “伪函数式编程” 风格的 library 的话，那下面这种风格的代码对你来说应该不陌生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void tryUsingGuava() &#123;</span><br><span class="line">    final int expectedLength = 4;</span><br><span class="line">    Iterables.filter(Lists.newArrayList(&quot;123&quot;, &quot;1234&quot;), new Predicate&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean apply(String str) &#123;</span><br><span class="line">            return str.length() == expectedLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码对一个字符串的 list 进行过滤，从中找出长度为 4 的字符串。看起来很是平常，没什么特别的。</p>
<p>但是，声明 expectedLength 时用的那个 final 看起来有点扎眼，把它去掉试试：</p>
<blockquote>
<p>error: local variable expectedLength is accessed from within inner class; needs to be declared final</p>
</blockquote>
<p>结果 Java 编译器给出了如上的错误，看起来匿名内部类只能够访问 final 的局部变量。但是，<strong>为什么呢？其他的语言也有类似的规定吗？</strong></p>
<p>在开始用其他语言做实验之前我们先把问题简化一下，不要再带着 guava 了，我们去除掉噪音，把问题归结为：</p>
<p><strong>为什么 Java 中的匿名内部类只可以访问 final 的局部变量呢？其他语言中的匿名函数也有类似的限制吗？</strong></p>
<h2 id="Scala-中有类似的规定吗？"><a href="#Scala-中有类似的规定吗？" class="headerlink" title="Scala 中有类似的规定吗？"></a>Scala 中有类似的规定吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def tryAccessingLocalVariable &#123;</span><br><span class="line">  var number = 123</span><br><span class="line">  println(number)</span><br><span class="line"></span><br><span class="line">  var lambda = () =&gt; &#123;</span><br><span class="line">    number = 456</span><br><span class="line">    println(number)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lambda.apply()</span><br><span class="line">  println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> |</p>
<p>上面的 Scala 代码是合法的，number 变量是声明为 var 的，不是 val（类似于 Java 中的 final）。而且在匿名函数中可以修改 number 的值。</p>
<p>看来 <strong>Scala 中没有类似的规定</strong>。</p>
<h2 id="C-中有类似的规定吗？"><a href="#C-中有类似的规定吗？" class="headerlink" title="C# 中有类似的规定吗？"></a>C# 中有类似的规定吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void tryUsingLambda ()</span><br><span class="line">&#123;</span><br><span class="line">  int number = 123;</span><br><span class="line">  Console.WriteLine (number);</span><br><span class="line"></span><br><span class="line">  Action action = () =&gt; &#123;</span><br><span class="line">      number = 456;</span><br><span class="line">      Console.WriteLine (number);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  action ();</span><br><span class="line">  Console.WriteLine (number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段 C# 代码也是合法的，number 这个局部变量在 lambda 表达式内外都可以访问和赋值。</p>
<p>看来 <strong>C# 中也没有类似的规定</strong>。</p>
<h2 id="分析谜团"><a href="#分析谜团" class="headerlink" title="分析谜团"></a>分析谜团</h2><p>三门语言中只有 Java 有这种限制，那我们分析一下吧。先来看一下 Java 中的匿名内部类是如何实现的：</p>
<p>先定义一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建这个接口的匿名子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TryUsingAnonymousClass &#123;</span><br><span class="line">    public void useMyInterface() &#123;</span><br><span class="line">        final Integer number = 123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        MyInterface myInterface = new MyInterface() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doSomething() &#123;</span><br><span class="line">                System.out.println(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myInterface.doSomething();</span><br><span class="line"></span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个匿名子类会被编译成一个单独的类，反编译的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class TryUsingAnonymousClass$1</span><br><span class="line">        implements MyInterface &#123;</span><br><span class="line">    private final TryUsingAnonymousClass this$0;</span><br><span class="line">    private final Integer paramInteger;</span><br><span class="line"></span><br><span class="line">    TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) &#123;</span><br><span class="line">        this.this$0 = this$0;</span><br><span class="line">        this.paramInteger = paramInteger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(this.paramInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到名为 number 的局部变量是作为构造方法的参数传入匿名内部类的（以上代码经过了手动修改，真实的反编译结果中有一些不可读的命名）。</p>
<p>如果 Java 允许匿名内部类访问非 final 的局部变量的话，那我们就可以在 TryUsingAnonymousClass$1 中修改 paramInteger，但是这不会对 number 的值有影响，因为它们是不同的 reference。</p>
<p>这就会造成数据不同步的问题。</p>
<p>所以，<strong>谜团解开了：Java 为了避免数据不同步的问题，做出了匿名内部类只可以访问 final 的局部变量的限制。</strong></p>
<p>但是，新的谜团又出现了：</p>
<h2 id="Scala-和-C-为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？"><a href="#Scala-和-C-为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？" class="headerlink" title="Scala 和 C# 为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？"></a>Scala 和 C# 为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？</h2><p>上面出现过的那段 Scala 代码中的 lambda 表达式会编译成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class TryUsingAnonymousClassInScala$$anonfun$1 extends AbstractFunction0.mcV.sp</span><br><span class="line">        implements Serializable &#123;</span><br><span class="line">    public static final long serialVersionUID = 0L;</span><br><span class="line">    private final IntRef number$2;</span><br><span class="line"></span><br><span class="line">    public final void apply() &#123;</span><br><span class="line">        apply$mcV$sp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void apply$mcV$sp() &#123;</span><br><span class="line">        this.number$2.elem = 456;</span><br><span class="line">        Predef..MODULE$.println(BoxesRunTime.boxToInteger(this.number$2.elem));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TryUsingAnonymousClassInScala$$anonfun$1(TryUsingAnonymousClassInScala $outer, IntRef number$2) &#123;</span><br><span class="line">        this.number$2 = number$2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 number 也是通过构造方法的参数传入的，但是与 Java 的不同是这里的 number 不是直接传入的，是被 IntRef 包装了一层然后才传入的。对 number 的值修改也是通过包装类进行的：this.number$2.elem = 456;</p>
<p>这样就保证了 lambda 表达式内外访问到的是同一个对象。</p>
<p>再来看看 C# 的处理方式，反编译一下，发现 C# 编译器生成了如下的一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private sealed class &lt;tryUsingLambda&gt;c__AnonStorey0</span><br><span class="line">&#123;</span><br><span class="line">  internal int number;</span><br><span class="line"></span><br><span class="line">  internal void &lt;&gt;m__0 ()</span><br><span class="line">  &#123;</span><br><span class="line">      this.number = 456;</span><br><span class="line">      Console.WriteLine (this.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 number 包装在这个类内，这样就保证了 lambda 表达式内外使用的都是同一个 number，即便重新赋值也可以保证内外部的数据是同步的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Scala 和 C# 的编译器通过把局部变量包装在另一个对象中，来实现 lambda 表达式内外的数据同步。</p>
<p>而 Java 的编译器由于未知的原因（怀疑是为了图省事儿？）没有做包装局部变量这件事儿，于是就只好强制用户把局部变量声明为 final 才能在匿名内部类中使用来避免数据不同步的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/21/为什么匿名内部类访问局部变量必须是 final/" data-id="cjrnxzmfq0004z7kmehl01kx0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-既然Java反射可以访问和修改私有成员变量，那封装成private的意义" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/21/既然Java反射可以访问和修改私有成员变量，那封装成private的意义/" class="article-date">
  <time datetime="2019-01-21T16:48:26.547Z" itemprop="datePublished">2019-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？"><a href="#既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？" class="headerlink" title="既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？"></a>既然Java反射可以访问和修改私有成员变量，那封装成private还有意义么？</h1><p>简单来说，private并不是解决“安全”问题的。<br>安全是指不让代码被非法看到/访问。但是只要人能拿到代码，总会有办法去查看和改变代码。<br>其他答案提到反射可以用SecurityManager来防止private被访问。但是从更高一层的角度，即便使用了SecurityManager，还是可以通过各种方式拿到java的bytecode，并做任意修改。比如有asm这样的lib，也有instrument api这种东西可以帮你。<br>所以记得，如果你真有一段代码不允许被别人看/用，就不要把这段代码放到其他人可以碰到的地方，而是做一个server，通过接口允许有限制的访问。其他人想破解，只能破解你的服务器网关和跳板机器。<br>关于真正的安全性，可以参考激活服务器的工作原理.<br>private想表达的不是“安全性”的意思，而是OOP的封装概念，是一种编译器可以帮助你的设计上的hint。这就像是一家没人的店挂了个牌子“闲人免进”，但你真要进去还是有各种办法可以办到。所以private，以及所有其他的access modifier都有一层隐含的含义：如果你按照遵守这套规则，开发者可以保证不问题（不考虑bug的情况下）；否则，后果自负。比如，你在用spring的IoC的时候，你知道你要“注入”，不管它是不是private的，你知道“注入”是你自己控制的，是你设计好的效果。那么通过spring的IoC利用反射帮你注入一些private property是再正常不过的用法。再比如，单元测试，你就想测一个private方法。但是因为private的缘故就是测不了。于是你可以用反射绕开这个限制，开心的做测试。虽说某些人坚持“不应该测试private方法，而应该通过测试其他方法间接测试private方法，但并没有形成广泛的共识。这里不对这个问题展开。虽然能绕开，但绕开的代码很繁琐。久而久之就会厌倦。毕竟，代码应该为你工作，而不是你为代码工作。<br>因此，我的经验是通常会用protected或者default来代替private。我曾设想runtime应该给一种运行模式，通过设定一个启动参数使其不管private这类的限制，这样做UT，做profiling等工作都会轻松许多。等到最后发布时，再用普通模式。但可惜现实当中并没有这种设定。评论区提到了Android里的VisibleForTesting，可以实现我期望的功能。大赞！感谢 @尤华杰<br>我之所以敢用protected/default来代替private是因为现实当中非private不可的情景非常少见。实际上，很多时候private带来的麻烦比起带来的好处要多，这是因为很多时候对OOP的误用造成的。OOP的误用造成了无谓的private，然后逼着你必须得绕开private。其实private就是个约定而已。<br>看看其他语言，比如python，它的“private“是一种很松散的约定，所有private的成员都用下划线开头，告诉调用者“不要随便调用我哦”，但是如果真调用了也就调用了。C++，通过指针就能绕开private。<br>有人说，private会避免新手误用。但问题是，大家从出道开始，自己或者周围的同事朋友有谁曾经出过这个问题？IDE知道一个成员当前不能访问，就根本就不会提示。如果一个人已经开始通过源代码/反编译研究“我能不能调用这个私有方法了“，他还算是一个菜鸟吗？他会不知道这里的潜在风险吗？如果真的误用了，code review能过吗？测试能过吗？如果一个公司因为误用private成员，造成了重大的损失，那这个公司就活该倒闭算了，不要在世上丢人。<br>OOP是一种编程思想，是众多编程思想中的一种。是开发者决定了一个问题应该用OOP合适，并且用了Java这样的语言来简化自己开发OOP代码时的工作。如果抱着这种态度，就不会误用，因为private在开发者的心中。其他人也不太可能误用，如果他上过几天java培训。不要因为语言是OOP的就去套，把不适合的OOP的代码强用OOP的各种套路实现，然后给自己后续的维护扩展埋坑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/21/既然Java反射可以访问和修改私有成员变量，那封装成private的意义/" data-id="cjrnxzmfu0007z7kmxccsz94e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-【深入理解 JVM】：类加载器与双亲委派模型 - smile4lee 的博客 - CSDN 博客" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/【深入理解 JVM】：类加载器与双亲委派模型 - smile4lee 的博客 - CSDN 博客/" class="article-date">
  <time datetime="2019-01-20T16:11:56.219Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 原文地址  <a href="https://blog.csdn.net/u011080472/article/details/51332866" target="_blank" rel="noopener">https://blog.csdn.net/u011080472/article/details/51332866</a></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h1><h2 id="加载类的开放性"><a href="#加载类的开放性" class="headerlink" title="加载类的开放性"></a><strong>加载类的开放性</strong></h2><p>类加载器（ClassLoader）是 Java 语言的一项创新，也是 Java 流行的一个重要原因。在类加载的第一阶段 “加载” 过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是<strong>类加载器</strong>。这一动作是放在 Java 虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。</p>
<p>虚拟机规范并没有指明二进制字节流要从一个 Class 文件获取，或者说根本没有指明从哪里获取、怎样获取。这种开放使得 Java 在很多领域得到充分运用，例如：</p>
<ul>
<li>从 ZIP 包中读取，这很常见，成为 JAR，EAR，WAR 格式的基础</li>
<li>从网络中获取，最典型的应用就是 Applet</li>
<li>运行时计算生成，最典型的是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流</li>
<li>有其他文件生成，最典型的 JSP 应用，由 JSP 文件生成对应的 Class 类<br>……</li>
</ul>
<h2 id="类加载器与类的唯一性"><a href="#类加载器与类的唯一性" class="headerlink" title="类加载器与类的唯一性"></a><strong>类加载器与类的唯一性</strong></h2><p>类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在 Java 虚拟机中的<strong>唯一性</strong>。通俗的说，JVM 中两个类是否 “相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。</p>
<p>这里的 “相等”，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p>
<p>以下代码说明了不同的类加载器对 instanceof 关键字运算的结果的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm.classloading;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 类加载器在类相等判断中的影响</span><br><span class="line"> * </span><br><span class="line"> * instanceof关键字</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 自定义类加载器</span><br><span class="line">        ClassLoader myLoader = new ClassLoader() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    if (is == null) &#123;</span><br><span class="line">                        return super.loadClass(fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] b = new byte[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    return defineClass(name, b, 0, b.length);   </span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    throw new ClassNotFoundException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 使用ClassLoaderTest的类加载器加载本类</span><br><span class="line">        Object obj1 = ClassLoaderTest.class.getClassLoader().loadClass(&quot;com.jvm.classloading.ClassLoaderTest&quot;).newInstance();</span><br><span class="line">        System.out.println(obj1.getClass());</span><br><span class="line">        System.out.println(obj1 instanceof com.jvm.classloading.ClassLoaderTest);</span><br><span class="line"></span><br><span class="line">        // 使用自定义类加载器加载本类</span><br><span class="line">        Object obj2 = myLoader.loadClass(&quot;com.jvm.classloading.ClassLoaderTest&quot;).newInstance();</span><br><span class="line">        System.out.println(obj2.getClass());</span><br><span class="line">        System.out.println(obj2 instanceof com.jvm.classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class com.jvm.classloading.ClassLoaderTest</span><br><span class="line">true</span><br><span class="line">class com.jvm.classloading.ClassLoaderTest</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>myLoader 是自定义的类加载器，可以用来加载与自己在同一路径下的 Class 文件。main 函数的第一部分使用系统加载主类 ClassLoaderTest 的类加载器加载 ClassLoaderTest，输出显示，obj1 的所属类型检查正确，这是虚拟机中有 2 个 ClassLoaderTest 类，一个是主类，另一个是 main() 方法中加载的类，由于这两个类使用同一个类加载器加载并且来源于同一个 Class 文件，因此这两个类是完全相同的。</p>
<p>第二部分使用自定义的类加载器加载 ClassLoaderTest，<code>class com.jvm.classloading.ClassLoderTest</code>显示，obj2 确实是类<code>com.jvm.classloading.ClassLoaderTest</code>实例化出来的对象，但是第二句输出 false。此时虚拟机中有 3 个 ClassLoaderTest 类，由于第 3 个类的类加载器与前面 2 个类加载器不同，虽然来源于同一个 Class 文件，但它是一个独立的类，所属类型检查是返回结果自然是 false。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h1><h2 id="类加载器种类"><a href="#类加载器种类" class="headerlink" title="类加载器种类"></a><strong>类加载器种类</strong></h2><p>从 Java 虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现（HotSpot 虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有 Java 语言实现，独立于虚拟机外部，并且全部继承自 java.lang.ClassLoader。</p>
<p>从开发者的角度，类加载器可以细分为：</p>
<ul>
<li><p>启动（Bootstrap）类加载器：负责将 Java_Home/lib 下面的类库加载到内存中（比如 rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p>
</li>
<li><p>标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 Java_Home /lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
</li>
<li><p>应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为<strong>系统（System）加载器</strong>。</p>
</li>
</ul>
<p>除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的<strong>双亲委派模型</strong>。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过<strong>组合（Composition）关系</strong>来实现，而不是通过继承（Inheritance）。</p>
<p><img src="https://img-blog.csdn.net/20160506184936657" alt=""></p>
<h2 id="双亲委派模型-1"><a href="#双亲委派模型-1" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h2><p><strong>双亲委派模型过程</strong></p>
<p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>使用双亲委派模型的好处在于 <strong>Java 类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。</p>
<p><strong>双亲委派模型的系统实现</strong></p>
<p>在 java.lang.ClassLoader 的 loadClass() 方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException&#123;</span><br><span class="line">    //check the class has been loaded or not</span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    if(c == null)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            if(parent != null)&#123;</span><br><span class="line">                c = parent.loadClass(name,false);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(ClassNotFoundException e)&#123;</span><br><span class="line">            //if throws the exception ,the father can not complete the load</span><br><span class="line">        &#125;</span><br><span class="line">        if(c == null)&#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(resolve)&#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，双亲委派模型是 Java 设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是 JDK 中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现，具体分析可以参见周志明著《深入理解 Java 虚拟机》。</p>
<p>参考<br>1、周志明，深入理解 Java 虚拟机：JVM 高级特性与最佳实践，机械工业出版社<br>2、Alexia(minmin) 博客，<a href="http://www.cnblogs.com/lanxuezaipiao/p/4138511.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/4138511.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/【深入理解 JVM】：类加载器与双亲委派模型 - smile4lee 的博客 - CSDN 博客/" data-id="cjrnxzmg70009z7kmlxpexbx2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/02/mysql explain 详解 _ Hexo/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/02/为什么你需要一个 vps _ Hexo/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/31/spring boot 扫描不到自定义 Controller/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/31/SpringCloud 警告 (Eureka)：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE./">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/29/蓄水池抽样算法/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 woo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>